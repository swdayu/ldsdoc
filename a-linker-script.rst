链接脚本
=========

* `基本概念`_
* `脚本格式`_
* `程序入口`_
* `处理文件`_
* `目标格式`_
* `区域别名`_
* `简单命令`_
* `符号赋值`_
* `表达式`_
* `内置函数`_

每个链接都由链接脚本控制，这个脚本使用链接器命令语言进行编写。链接脚本的主要目的是描述输
入目标文件中的分区怎样映射到输出目标文件中，并且控制输出目标文件的内存布局。大多数链接脚
本做的事不超过这个范围。然而在需要时，链接脚本还可以使用下文描述的命令，直接控制链接器执
行很多其他操作。

链接器总是会使用一个链接脚本，如果你不提供一个，链接器会使用已经编译到链接器可执行文件中
的默认脚本。可以使用 --verbose 命令行选项打印出这个默认链接脚本。一些命令行选项，例如
-r 或者 -N，会影响默认链接脚本。

可以使用命令行参数 -T 指定自己的链接脚本，这样你提供的链接脚本会替换掉默认的脚本。还可以
通过将脚本名称作为输入文件传给链接器，隐式地使用链接脚本，就好像它们是要链接的文件一样。

如果你给链接器指定了一个输入文件，但是链接器不能将它识别成目标文件或者库文件的时候，它会
尝试将这个文件识别为链接脚本文件。如果这个文件不能被解析成链接脚本，链接器就会报错。这种
方式提供的连接脚本，被称为是隐式链接脚本。注意，隐式链接脚本不会替换掉默认脚本。通常，一
个隐式脚本仅仅包含符号赋值、或者 INPUT、GROUP、VERSION 等命令。如果隐式脚本中包含了处
理文件的命令，这些文件只会在该隐式脚本所在的目录进行搜索。这可能会影响库文件的搜索。

基本概念
--------

我们需要定义一些基本概念和词汇来描述链接脚本语言。链接器将输入目标文件合并成单个输出目标
文件，输入和输出目标文件使用一种特别的数据格式表示的，称为目标文件格式。输出目标文件通常
是可执行文件，但我们将输入输出文件都统称为目标文件。每个目标文件除了其他内容外，是一个由
分区组成的列表。有时将输入文件中分区称为输入分区，输出文件中的分区称为输出分区。

目标文件中的每个分区都有一个名字和对应长度，大部分分区还有一个关联的数据块，称为分区内容。
一个分区可以被标记成是可以加载的，表示当目标文件执行时这些分区需要加载到内存中。一个没有
内容的分区可以是可分配的，这表示一个内存区域需要分配出来使用，但是没有特别的内容需要加载
到这个分区，一些情况下分配出的内存需要设成全零。一个既不是可加载也不是可分配的分区，通常
用来包含某些调试信息。

每个可加载或可分配的输出分区由两个地址，一个是虚拟地址 VMA（virtual memory address），
这种地址是目标文件运行时分区拥有的地址。第二种是加载地址 LMA（load memory address）,
这是分区被加载的地址。在大多数情况下，两种地址是相同的。一个可能两个地址不同的情况是，一
个数据分区在程序开始执行时被加载到 ROM 并且拷贝到 RAM（这个技术常用于在基于 ROM 的系统
中初始化全局变量）。在这种情况下，加载地址是 ROM 地址，而虚拟地址是 RAM 地址。

使用 objdump 工具以及 -p 选项来查看目标文件中的分区。每个目标文件还有一个符号列表，称为
符号表。一个符号是定义的或者未定义的。每个符号都有一个名字，并且每个定义的符号除了其他信
息还都有一个地址。如果将 C/C++ 程序编译成目标文件，每个已经定义的函数和全局或静态变量都
有一个对应的定义的符号。输入目标文件中每个被引用的未定义函数或全局变量，是一个未定义符号。

可以使用 nm 工具查看目标文件中的符号，也可以使用 objdump 工具以及 —t 选项来查看。

脚本格式
---------

链接脚本是文本文件，一个书写的链接脚本是一连串的命令序列。每个命令或是一个关键字，可能后
面跟有参数，或者是一个符号赋值。使用使用分号来分隔命令，空白字符空白会被忽略。

字符串，例如文件或格式名称，可以直接书写。如果文件名包含特殊字符，比如用来分隔文件名的逗
号，可以将名称放到双引号中。因此文件名中不能包含双引号。

可以像 C 语言一样在链接脚本中使用注释，由 ``/*`` 开始到 ``*/`` 结束。跟 C 相同，注释在
语法上等价于空白字符。

很多链接脚本都很简单，最简单的链接脚本可能只有一条 SECTIONS 命令。可以使用 SECTIONS 命
令来描述输出目标文件的内存布局。假设程序仅包含代码、初始化数据、以及未初始化数据，分别对
应 .text、.data、.bss 分区，并且输入目标文件也只有这些分区。这里价绍 SECTIONS 命令的一
个简单用法，将代码加载到 0x10000 位置，并且数据必须在 0x80000000 位置，那么链接脚本的
写法如下： ::

    SECTIONS
    {
        . = 0x10000;
        .text : { *(.text) }
        . = 0x80000000;
        .data : { *(.data) }
        .bss : { *(.bss) }
    }

其中的第一行，将特殊符号 . 的值设为 0x10000，这个特殊符号是位置计数器。在 SECTIONS 命
令开头，位置计数器的值为 0。如果没有给输出目标文件指定地址，它们的地址是当前的位置计数。
然后位置计数器会增加输出分区的大小到计数上。

第二行定义了一个输出分区 .text，在大括号内，列出了需要放到这个分区的输入分区的名称。其中
符号 * 是通配符，表达式 ``*(.text)`` 的含义是输入目标文件中的所有代码分区。因为当前的位
置计数的值是 0x10000，因此链接器会设置输出目标文件中的 .text 分区的地址为 0x10000。

然后，.data 分区起始地址是 0x80000000，.bss 分区的地址是 0x80000000 加上 .data 分区
的大小。链接器会保证每个分区的地址对齐要求，如果需要会自动增加位置计数器的计数。这个例子
中，.text 和 .data 分区可能以及满足对齐要求，但是链接器可能会在 .data 和 .bss 分区之间
插入一个填充内容。

程序入口
---------

程序中第一个执行的指令是程序入口点（entry point），可以使用 ENTRY 链接器脚本命令指定入
口点： ::

    ENTRY(symbol)

有几种设置入口点的方法，链接器会按顺序尝试以下的方法来设置：

1. 命令行参数 -e entry
2. ENTRY(symbol) 脚本命令
3. 特定目标文件定义的符号，大多数是 start 符号，但像 PE 和基于 BeOS 的系统会检查一系列
   可能的入口符号，选择第一个匹配的作为入口
4. 代码分区中的第一个字节的地址，如果代码分区存在并且创建的是一个可执行文件，代码分区通
   常是 .text，但也可能是其他名称
5. 地址 0

处理文件
--------

处理文件的链接命令：

INCLUDE filename
    包含一个链接脚本文件，会在当前目录、所有 -L 命令行选项指定的目录查找这个文件，文件
    包含的最大嵌套深度为 10，可以在脚本文件顶层、MEMORY 或 SECTIONS 命令内部、输出分区
    的描述中使用该命令。

INPUT(file, file, ...) INPUT(file file ...)
    让链接器包含这些文件，就像这样文件是命令行中指定的文件一样。例如，在链接时不管怎样都
    需要包含一个 subr.o 文件，但是不想总是在命令行中设置，就可以写好在链接脚本中 INPUT(subr.o)。
    实际上，你可以将所有的输入文件都写到链接脚本中，并且不需要指定除 -T 外的任何选项。
    如果配置了 sysroot 前缀，并且文件名以斜杠字符（/）开头，并且正在处理的链接脚本在该
    前缀目录中，会在前缀目录里搜索该文件名。该前缀也可以通过使用 = 字符作为文件路径的第
    一个字符，或者 $SYSROOT，来强制指定前缀。更多见 -L 命令行选项的描述。

    如果没有使用 sysroot 前缀，链接器会在包含链接脚本的目录打开这个文件。如果没有找到，
    链接器会搜索当前目录。还没有找到，会搜索库搜索目录。如果使用 INPUT(-lfile)，链接器
    会将名字转换成 libfile.a，像使用 -l 命令行选项一样。如果在隐式链接脚本中使用 INPUT
    命令，文件会在连接脚本所在目录进行搜索，这可能会影响到库文件的搜索。

GROUP(file, file, ...) GROUP(file file ...)
    与 INPUT 命令类似，除了文件需要是库文件，并且这些库文件会重复的搜索指定没有未定义的
    引用。见 -( 命令行选项。

AS_NEEDED(file, file, ...) AS_NEEDED(file file ...)
    仅能出现在 INPUT 或 GROUP 命令的内部，并排在其他文件名称之中。其中的文件就像是直接
    写在 INPUT 或 GROUP 命令中一样，除了 ELF 共享库。ELF 共享库只有当真正需要时才会添
    加。该命令就像是为其中列出的所有文件开启了 --as-needed 选项，并且之后对前面的 --as-needed
    或者 --no-as-needed 进行恢复。

OUTPUT(filename)
    设置输出文件名称，就像是在命令行中使用 -o filename 选项。如果两者都使用了，命令行
    选项优先。可以使用该命令定义一个不同于普通默认名称（a.out）的默认输出名。

SEARCH_DIR(path)
    添加库搜索路径，就像是在命令行中使用 -L path 选项。如果两者都指定了，命令行中指定的
    路径会先搜索，然后才搜索该命令指定的。

STARTUP(filename)
    跟 INPUT 命令类型，处理该文件会当成链接的第一个输入文件，就像是该文件是命令行中的第
    一个输入文件一样。在入口点总是在第一个文件的起始处的系统上，这个命令是很有用的。

目标格式
---------

处理目标文件格式的链接命令，其中 BFD 表示的是目标文件的格式（Binary File Descriptor）：

OUTPUT_FORMAT(bfdname) OUTPUT_FORMAT(default, big, little)
    指定输出文件使用的 BFD 格式，就像是在命令行中使用 --oformat bfdname 一样。如果两者
    都指定了，命令行中指定的优先。可以用三个参数版本的 OUTPUT_FORMAT 命令基于 -EB 和
    -EL 命令行选项指定的内容选择使用不同的格式，这允许连接脚本基于所需的字节序要求设置
    输出文件格式。如果命令行没有指定 -EB 或 -EL 选项，则使用第一个参数指定的默认格式，
    如果指定了 -EB 则使用第二个参数指定的格式，如果制定了 -EL 则使用第三个参数指定的格
    式。例如，MIPS ELF 目标平台使用的默认链接脚本使用了该命令： ::

        OUTPUT_FORMAT(elf32-bigmips, elf32-bigmips, elf32-littlemips)

TARGET(bfdname)
    该命令用于指定输入文件的 BFD 格式，会影响该命令之后的 INPUT 和 GROUP 命令。该命令
    就像在命令行中使用 -b bfdname 一样。如果使用了 TARGET 命令但没有使用 OUTPUT_FORMAT
    命令，那么 TARGET 指定的格式也用于输出文件格式。

可以使用 objdump -i 列出当前系统支持的所有目标文件格式，例如： ::

         elf64-x86-64 elf32-i386 elf32-iamcu elf32-x86-64 pei-i386 pei-x86-64
    i386 elf64-x86-64 elf32-i386 ----------- elf32-x86-64 pei-i386 pei-x86-64
    l1om ------------ ---------- ----------- ------------ -------- ----------
    k1om ------------ ---------- ----------- ------------ -------- ----------
   iamcu ------------ ---------- elf32-iamcu ------------ -------- ----------

         elf64-l1om elf64-k1om elf64-little elf64-big elf32-little elf32-big
    i386 ---------- ---------- elf64-little elf64-big elf32-little elf32-big
    l1om elf64-l1om ---------- elf64-little elf64-big elf32-little elf32-big
    k1om ---------- elf64-k1om elf64-little elf64-big elf32-little elf32-big
   iamcu ---------- ---------- elf64-little elf64-big elf32-little elf32-big

         pe-x86-64 pe-bigobj-x86-64 pe-i386 srec symbolsrec verilog tekhex
    i386 pe-x86-64 pe-bigobj-x86-64 pe-i386 srec symbolsrec verilog tekhex
    l1om --------- ---------------- ------- srec symbolsrec verilog tekhex
    k1om --------- ---------------- ------- srec symbolsrec verilog tekhex
   iamcu --------- ---------------- ------- srec symbolsrec verilog tekhex

         binary ihex plugin
    i386 binary ihex ------
    l1om binary ihex ------
    k1om binary ihex ------
   iamcu binary ihex ------

区域别名
---------

别名可以添加到已经存在的由 MEMORY 命令创建的内存区域中，每个别名最多与一个内存区域对应。
REGION_ALIAS 函数为内存区域创建一个别名，这样允许将输出分区灵活地映射到内存区域中： ::

    REGION_ALIAS(alias, region)

假设嵌入式系统上的一个应用程序，该系统配备了各种存储器，例如一个通用的易失性内存 RAM 允
许代码执行和数据存储，一个只读的非易失性内存 ROM 允许代码执行和只读数据访问，可能还有一
个只读的非易失性内存 ROM2 具有只读数据访问能力但没有代码执行能力。我们有四个输出分区：

- .text 程序代码
- .rodata 只读数据
- .data 可读可写初始化数据
- .bss 可读可写零初始化数据

目标是提供一个链接脚本文件，其中包含一个系统无关的部分定义输出分区，以及一个系统相关的部
分将输出分区映射到系统可用的内存区域。假设我们的嵌入式系统配置了三种不同的内存配置 A、B、
C： ::

    分区        配置A       配置B       配置C
    .text       RAM         ROM         ROM
    .rodata     RAM         ROM         ROM2
    .data       RAM         RAM/ROM     RAM/ROM2
    .bss        RAM         RAM         RAM

其中 RAM/ROM 和 RAM/ROM2 表示将这个分区加载到区域 ROM 或区域 ROM2。注意，.data 分区的
加载地址在所有三种配置中都是从 .rodata 分区的末尾开始。下面的基本链接脚本定义输出分区，
它包含了一个系统相关的 linkcmds.memory 脚本文件用来描述特定的内存布局： ::

    INCLUDE linkcmds.memory

    SECTIONS
    {
        .text : { *(.text) } > REGION_TEXT
        .rodata : { *(.rodata) rodata_end = .; } > REGION_RODATA
        .data : AT (rodata_end) { data_start = .; *(.data) } > REGION_DATA
        data_size = SIZEOF(.data);
        data_load_start = LOADADDR(.data);
        .bss : { *(.bss) } > REGION_BSS
    }

接着我们需要三个不同的 linkcmds.meory 脚本文件来定义不同的内存区域和区域别名。三种不同
配置的脚本文件内容如下。

配置 A，所有的内容放到 RAM： ::

    MEMORY
    {
        RAM : ORIGIN = 0, LENGTH = 4M
    }

    REGION_ALIAS("REGION_TEXT", RAM);
    REGION_ALIAS("REGION_RODATA", RAM);
    REGION_ALIAS("REGION_DATA", RAM);
    REGION_ALIAS("REGION_BSS", RAM);

配置 B，代码和只读数据放到 ROM，可读可写代码放到 RAM，其中初始化数据被加载到 ROM 会在系
统启动时拷贝到 RAM： ::

    MEMORY
    {
        ROM : ORIGIN = 0, LENGTH = 3M
        RAM : ORIGIN = 0x10000000, LENGTH = 1M
    }

    REGION_ALIAS("REGION_TEXT", ROM);
    REGION_ALIAS("REGION_RODATA", ROM);
    REGION_ALIAS("REGION_DATA", RAM);
    REGION_ALIAS("REGION_BSS", RAM);

配置 C，代码放置到 ROM，只读数据放到 ROM2，可读可写数据放到 RAM，其中初始化数据被加载到
ROM2 会在系统启动时拷贝到 RAM： ::

    MEMORY
    {
        ROM : ORIGIN = 0, LENGTH = 2M
        ROM2 : ORIGIN = 0x10000000, LENGTH = 1M
        RAM : ORIGIN = 0x20000000, LENGTH = 1M
    }

    REGION_ALIAS("REGION_TEXT", ROM);
    REGION_ALIAS("REGION_RODATA", ROM2);
    REGION_ALIAS("REGION_DATA", RAM);
    REGION_ALIAS("REGION_BSS", RAM);

如果需要，可以编写一个公共的系统初始化过程将 .data 分区从 ROM 或 ROM2 拷贝到 RAM： ::

    #include <string.h>
    extern char data_start[];
    extern char data_size[];
    extern char data_load_start[];

    void copy_data(void)
    {
        if (data_start != data_load_start)
        {
            memcpy(data_start, data_load_start, (size_t)data_size);
        }
    }

简单命令
--------

其他一些简单命令：

ASSERT(exp, message)
    确保 exp 为非零值，如果是零会退出链接器，并打印错误。注意该命令会在链接器最后一个步
    骤执行之前被检查。这也意味着，如果在分区定义内部引用 PROVIDE 符号，除了该符号引用的
    是一个点号（.），否则如果存在符号没有在其他地方赋值，断言就会失败。例如： ::

        .stack :
        {
            PROVIDE(__stack = .);
            PROVIDE(__stack_size = 0x100);
            ASSERT((__stack > (_end + __stack_size)), "Error: No room left for the stack");
        }

    如果 __stack_size 在其他地方没有定义，断言会失败。因为在分区定义外部的 PROVIDE 符
    号会更早求值，因此可以用在断言名两种。例如下面的断言会正常工作： ::

        PROVIDE (__stack_size = 0x100);
        .stack :
        {
            PROVIDE (__stack = .);
            ASSERT ((__stack > (_end + __stack_size)), "Error: No room left for the stack");
        }

EXTERN(symbol symbol ...)
    强制将符号作为未定义符号放入输出文件中，这样可能触发链接器比如从标准库链接额外的模块。
    可以在一个命令中指定多个文件，也可以多次使用这个命令。该命令与命令行选项 -u 有相同的
    效果。

FORCE_COMMON_ALLOCATION
    与命令行选项 -d 有相同的效果：即使指定了重定位输出文件（-r），也强制分配通用符号的
    空间

INHIBIT_COMMON_ALLOCATION
    与命令行选项 --no-define-common 有相同的效果：即使对于非重定位输出文件，也让链接器
    忽略对通用符号的地址分配

FORCE_GROUP_ALLOCATION
    与命令行选项 --force-group-allocation 有相同的效果：使链接器像正常输入分区一样处理
    分区分组的成员，并且删除这个分区分组即使指定了一个重定位输出文件（-r）

INSERT [AFTER|BEFORE] output_section
    这条命令通常在由 -T 选项指定的脚本中使用，以对默认的 SECTIONS 进行补充，例如添加
    overlay。它会将前面所有的链接脚本语句插入到 output_section 之前或之后，并且使 -T
    选项不覆盖默认的链接脚本。具体的插入点与孤立分区的输出规则相同。这种插入，发生在链接
    器将输入分区映射到输出分区处理完之后。在插入之前，由于 -T 脚本在默认脚本之前解析，
    -T 脚本中的语句出现在默认脚本语句之前。特别地，输入分区首先会被分配到 -T 的输出分区，
    优先于默认脚本的输出分区。下面是一个 -T 脚本怎样使用 INSERT 的例子： ::

        SECTIONS
        {
            OVERLAY :
            {
                .ov1 { ov1*(.text) }
                .ov2 { ov2*(.text) }
            }
        }
        INSERT AFTER .text;

    注意，如果 -T 选项使用了两次，一个用来覆盖默认脚本，另一个使用 INSERT 对默认脚本补
    充解析顺序和分区分配。那么包含 INSERT命令的脚本 -T 选项必须首先出现。

NOCROSSREFS(section section ...)
    这条命令用来告诉链接器，在某些输出分区之间发生任何引用都是一个错误。在某些类型的程序
    中，特别是在使用 overlay 的嵌入式系统中，当一个分区被加载到内存时，另一个将不会被加
    载。两个分区之间的任何直接引用都是错误的。例如，如果一个分区中的代码调用了另一个分区
    中定义的函数，那么将是一个错误。

    NOCROSSREFS 命令接受一系列输出分区名称，如果链接器检测到分区之间有任何交叉引用，会
    报错并返回一个非零退出状态。注意该命令使用的时输出分区名称，而不是输入分区名称。

NOCROSSREFS_TO(tosection fromsection ...)
    这条命令用来告诉链接器，如果从一个分区列表（fromsection ...）中的任何一个分区引用
    另一个分区（tosection）时是错误的。该命令在确保两个或多个输出分区是完全独立的，但是
    具有一种单向依赖性。例如在多核应用中，每个核都可以调用共享代码，但为了安全起见，共享
    代码绝不允许回调。

    NOCROSSREFS_TO 命令接受一些列输出分区名称，第一个分区被被其他分区引用。如果链接器
    检测到从其他分区有任何一个到第一个分区的任何引用，都会报错并返回一个非零退出状态。注
    意该命令使用的时输出分区名称，而不是输入分区名称。

OUTPUT_ARCH(bfdarch)
    指定一个输出架构，可以使用 objdump -f 查看一个目标文件的架构信息。

LD_FEATURES(string)
    这个命令可以用来修改链接器的行为，如果字符串是 "SANE_EXPR" 那么在脚本中的绝对符号和
    数字在任何地方都简单地被当作数字处理。见下文表达式部分。

其中 -r 或 --relocatable 命令行选项表示产生重定位输出，即生成的目标文件可以反过来作为
链接器的输入文件使用，这种链接称为部分链接。如果在支持标准 Unix 的魔数，这个选项还会设置
输出文件的魔数为 OMAGIC。如果没有指定这个选项，会产生一个绝对定位文件。

符号赋值
---------

链接脚本中可以给一个符号赋值，这会定义个符号并且会添加到全局作用域的符号表中。可以使用任
何 C 语言赋值操作符给符号赋值： ::

    symbol = expression ;
    symbol += expression ;
    symbol -= expression ;
    symbol *= expression ;
    symbol /= expression ;
    symbol <<= expression ;
    symbol >>= expression ;
    symbol &= expression ;
    symbol |= expression ;

第一种情况定义符号为表达式的值，其他情况下符号必须已经定义，其值将调整为新值。有一个特殊
的符号用点号（.）表示，是位置计数器当前的值，只能在 SECTIONS 命令中使用。表达式之后的分
号是必须的。可以将符号赋值作为独立的命令书写，或作为 SECTIONS 命令中的语句，或作为 SECTIONS
命令中的输出分区描述的一部分。符号的分区基于表达式的分区进行设置，见下文表达式部分。下面
的例子展示了三个不同地方的符号赋值的使用： ::

    floating_point = 0;
    SECTIONS
    {
        .text :
        {
            *(.text)
            _etext = .;
        }
        _bdata = (. + 3) & ~ 3;
        .data : { *(.data) }
    }

其中，符号 floating_point 的值定义为 0，符号 _etext 定义为最后一个 .text 输入分区之后
的地址，符号 _bdata 定义为 .text 输出分区之后的地址并向上对齐到4字节地址边界。

**HIDDEN**

对于 ELF 目标格式，可以使用 HIDDEN 隐藏符号定义，这种符号不能导出，只能在目标文件内部使
用。例如： ::

    HIDDEN(floating_point = 0);
    SECTIONS
    {
        .text :
        {
            *(.text)
            HIDDEN(_etext = .);
        }
        HIDDEN(_bdata = (. + 3) & ~ 3);
        .data : { *(.data) }
    }

**PROVIDE**

在某些情况下，可能需要定义一个符号，并且只有在该符号被引用但在链接的所有目标文件中都没有
被定义时才定义。例如，传统链接器定义了符号 etext，而 ANSI C 要求用户能够将 etext 作为
函数名使用，就可以将该符号定义为 PROVIDE，仅当该符号被引用但没有定义时才定义。例如： ::

    SECTIONS
    {
        .text :
        {
            *(.text)
            _etext = .;
            PROVIDE(etext = .);
        }
    }

在这个例子中，如果程序代码中定义了符号 _etext（有一个前置下划线），链接器会报重复定义，
因为链接脚本中已经定义这个符号。如果程序中定义了符号 etext（没有下划线），链接器会使用这
个定义，链接脚本中的 etext 定义会被忽略。如果程序中没有定义 etext，但是引用了这个符号，
那么会使用链接脚本中定义的 etext 符号。

注意，PROVIDE 命令认为通用符号是已经定义的符号，即使这样的符号可以与 PROVIDE 创建的符号
进行合并。这一点非常重要，特别是对于 __CTOR_LIST__ 这样的构造函数和析构函数列表符号，因
为它们通常被定义为通用符号。

**PROVIDE_HIDDEN**

跟 PROVIDE 类似，并且在 ELF 目标格式中，这个符号还是隐藏的不能导出。

**代码访问**

在程序源代码中访问链接脚本中定义的符号并不直观，特别是链接脚本符号并不等同与高级语言中的
变量声明，它实际上是一个没有值的符号。另一个重要的需要注意的点是，编译器经常在将名称存储
在符号表中时，将源代码中的名称转换成不同的名称。例如 Fortran 编译器通常在名称前面或后面
添加下划线，而 C++ 还会执行扩展的名称装饰（name mangling）。因此，源代码中使用的变量名
称与链接器中定义的相同变量名之间可能存在差异。例如，在链接脚本中定义的符号 ``_foo = 1000;``
在 C 语言中可能被引用成 ``extern int foo;``。但是在以后的例子中，我们假设不存在这种名
字转换。

当一个符号定义了像 C 语言这样的高级语言中时，会发生两件事。首先，编译器会在程序内存中为
变量预留足够大的空间；第二，是编译器会为该变量在符号表中创建一个对应名称的符号，保存变量
对应内存空间的地址。当程序引用一个变量时，编译器首先从符号表中找到对应的符号，再找到对应
内存空间的地址，才能确定变量的值。例如 ``int *a = &foo;`` 会先找到 foo 对应的符号，然
后将其中保存的内存地址拷贝到变量 a 关联的符号指向的内存地址位置。

但是链接脚本中声明的符号，相反，只是在符号表中创建了一个符号条目，但是并没有赋予任何内存
区域。因此它们是有地址的但没有值（没有分配内存）。因此链接脚本中的定义 ``foo = 1000;``，
创建了一个名为 foo 的符号，它存储的地址是 1000，但是并没有指定特别的值保存在位置是 1000
的地址上。因此，在程序源代码中，你不能访问链接脚本定义的符号的值（因为它没有值），你所有
能做的只能访问符号的地址。

因此在源代码中访问链接脚本中的符号，只能总是获取符号的地址，绝不能尝试使用它的值。例如一
个链接脚本定义了以下符号： ::

    start_of_ROM = .ROM;
    end_of_ROM = .ROM + sizeof (.ROM);
    start_of_FLASH = .FLASH;

如果要将 .ROM 内存区域的内容拷贝到 .FLASH 对用的区域，在 C 源代码中必须使用地址： ::

    extern char start_of_ROM, end_of_ROM, start_of_FLASH;
    memcpy(&start_of_FLASH, &start_of_ROM, &end_of_ROM - &start_of_ROM);

    extern char start_of_ROM[], end_of_ROM[], start_of_FLASH[];
    memcpy(start_of_FLASH, start_of_ROM, end_of_ROM - start_of_ROM);

表达式
-------

链接脚本语言的表达式语法和 C 语言的表达式是相同的，除了空白字符在以下情况中是必需的情况
例外，这种情况下需要用空白来解决语法歧义。所有的表达值的求值结果都是整数。所有表达式的求
值结果都有相同的大小，即如果目标平台是32位时为32位值，否则为64位值。可以在表达式用使用和
设置符号的值。链接器还定义了一些特殊目的的函数用于表达式。

**常量**

所有的常量都是整数，像 C 一样，链接器将以 0 开始的整数当作八进制整数，以 0x 或 0X 开始
的整数当作十六进制整数。另外，链接器接受以 h 或 H 后缀结尾的十六进制整数，以及以 o 或 O
结尾的八进制整数，以 b 或 B 结尾的二进制整数，以 d 或 D 结尾的十进制整数。所有没有缀和
后缀的整数都被当作十进制整数。并且，如果使用后缀 K 或者 M 可以将整数常量放大 1024 被或
1024^2 倍，但是 K 和 M 不能与前面的整数后缀一起使用。例如下面的值都是相同的： ::

    _fourk_1 = 4K;
    _fourk_2 = 4096;
    _fourk_3 = 0x1000;
    _fourk_4 = 10000o;

可以使用 CONSTANT(name) 来引用特定平台的常量，其中 name 可以是：

MAXPAGESIZE
    特定平台的最大内存页大小
COMMONPAGESIZE
    特定平台默认的内存页大小

例如以下输出分区的定义，会将分区对齐到特定平台支持的最大页面大小边界的地址上： ::

    .text ALIGN (CONSTANT (MAXPAGESIZE)) : { *(.text) }

**符号名称**

未引起的符号名称，以字母、下划线、点号开始，并且可能包含字母、数字、下划线、点号、以及横
杠字符。未引起的符号不能与关键字冲突。而以双引号引起的符号，可以使用任何古怪的字符，并且
可以是关键字，例如： ::

    "SECTION" = 9;
    "with a space" = "also with a space" + 10;

由于符号可以包含很多非字母字符，因此最安全的方式是在符号周围使用空格与其他内容分隔。例如，
A-B 是一个符号，而 A - B 是一个涉及减法的表达式。

**孤立分区**

孤立分区是输入目标文件中存在的分区，这些分区没有被链接脚本显式地输出到输出文件中。链接器
仍然会将这些分区复制到输出文件中，要么创建要么找到已经存在的分区来保存孤立输入分区。如果
孤立的输入分区的名称与现有输出分区的名称完全匹配，那么这个孤立分区将被保存到给输出分区的
末尾。如果不存在名称匹配的输出分区，就会创建新的同名输出分区保存孤立输入分区的内容，如果
存在多个同名的输入分区，都会保存到同一个相同名称的输出分区中。

如果创建了新的输出分区来保存孤立输入分区的内容，链接器必须确定这个新的输出分区放置到输出
文件的哪个位置。在大多数目标平台上，链接器会尝试将分区放置到具有相同属性的分区之后，例如
是代码还是数据、是可加载还是不可加载，等等。如果没有找到具有匹配属性的分区，或者你的目标
平台不支持此功能，孤立输出分区将被防止到文件的末尾。

命令行选项 --orphan-handling 和 --unique 可以控制将孤立分区放置到哪个输出分区。

**位置计数器**

特殊的符号（.）总是包含当前输出位置计数，仅可以出现在 SECTIONS 命令内的表达式中。给该符
号赋值，会改变当前位置计数，这可以用来在输出分区中创建空洞。位置计数不能在输出分区中往后
移，只能往前移。在输出分区外部，如果后移会创建重叠的 LMA 区域，也不能往后移。位置计数的
一个例子如下： ::

    SECTIONS
    {
        output :
        {
            file1(.text)
            . = . + 1000;
            file2(.text)
            . += 1000;
            file3(.text)
        } = 0x12345678;
    }

其中，来自于 file1 的 .text 分区位于输出分区的开始处，然后是一个 1000 字节的空洞，然后
是来自于 file2 的 .text 分区，再接着是一个 1000 字节的空洞，然后是来自于 file3 的 .text
分区。最后的 ``= 0x12345678`` 设定空洞中需要填充的数据。

该符号（.）实际表示的是当前包含点符号的目标的起始位置开始的偏移。正常包含点字符的是 SECTIONS
语句，它的起始地址从 0 开始，因此点符号可以用作绝对地中。但是如果包含点字符的是分区描述，
那么此时点字符就不是一个绝对地址，而是从该分区描述开始的偏移。例如： ::

    SECTIONS
    {
        . = 0x100
        .text: {
            *(.text)
            . = 0x200
        }
        . = 0x500
        .data: {
            *(.data)
            . += 0x600
        }
    }

其中 .text 分区的起始地址是 0x100，并且其大小是 0x200 字节，如果 .text 实际的大小超过
0x200 就会产生一个错误，因为这相当于要将位置计数往后移。然后 .data 分区的起始地址是 0x500，
并且它的大小是所有 .data 输入分区的大小加上一个额外的 0x600 字节。

在分区之外设置将符号的值设置成当前的位置计数，在插入孤独分区的情况下，可能导致不预期的值。
例如： ::

    SECTIONS
    {
        start_of_text = . ;
        .text: { *(.text) }
        end_of_text = . ;

        start_of_data = . ;
        .data: { *(.data) }
        end_of_data = . ;
    }

例如链接器可能将 .rodata 孤立分区插入到 .text 分区和 .data 分区之间。链接器会把赋值和
其他语句都当作是属于前一个分区。这样可能导致改变 start_of_data 原本的含义。 ::

    SECTIONS
    {
        start_of_text = . ;
        .text: { *(.text) }
        end_of_text = . ;

        start_of_data = . ;
        .rodata: { *(.rodata) }
        .data: { *(.data) }
        end_of_data = . ;
    }

这时需要添加一条点符号赋值给自己的一条语句，表示从从这条语句开始以及后面的语句都属于下一
个输出分区，从而可以让链接器将这些语句和分区看成一个整理。这样在插入上面的 .rodata 孤立
分区时，会插入到点符号自我赋值语句的前面。 ::

    SECTIONS
    {
        start_of_text = . ;
        .text: { *(.text) }
        end_of_text = . ;

        . = . ;
        start_of_data = . ;
        .data: { *(.data) }
        end_of_data = . ;
    }

**操作符和求值**

链接器可以识别标准 C 语言中的算术操作符： ::

    最高优先级  结合性      操作符
    1           左结合      - ~ !   （一元操作符）
    2           左结合      * / %
    3           左结合      + -
    4           左结合      >> <<
    5           左结合      > < <= >=
    6           左结合      == !=
    7           左结合      &
    8           左结合      ^
    9           左结合      |
    10          左结合      &&
    11          左结合      ||
    12          右结合      ? :
    13          右结合      += -= *= /= <<= >>= &= |= ^=
    最低优先级

链接器会进行懒惰表达式求值，它只在绝对必要时才会计数表达式的值。链接器需要一些信息，比如
第一个分区的起始地址的值，内存区域的起始点以及长度，才能进行链接操作。这些值会在链接器读
取链接脚本时尽快计算。

然而，其他值（比如符号值）在存储分配之后才被知道或需要，这些值在分区或内存区域信息可用于
符号赋值表达式时才被计算。分区的大小只有在分配之后才知道，因此依赖于这些大小的赋值直到分
配之后才执行。一些表达式，比如依赖于位置计数器的表达式，必须在分区分配期间进行求值。如果
需要计算一个表达式的结果，但是值现在还不可用，那么将会报错。例如： ::

    SECTIONS
    {
        .text 9+this_isnt_constant : { *(.text) }
    }

该脚本会报 non constant expression for initial address 的错误。

**分区相对值**

地址和符号可以是相对于分区的值，或者是绝对值。相对于分区的符号是可重定位的，如果使用 -r
命令行选项输出重定位文件，链接器进一步的操作可能会修改相对于分区的符号的值。但是绝对符号
的值总是保持不变。

链接器表达式中的一些符号是地址，也即相对于分区的符号以及返回地址的内置函数来说式正确的，
例如 ADDR，LOADADDR，ORIGIN，SEGMENT_START。其他一些符号以及返回非地址值的函数只是数
值，例如 LENGTH。一个复杂之处是，除非设置了 LD_FEATURES("SANE_EXPR")，数值和绝对值符
号根据它们出现的位置不同以不同的方式处理，以兼容旧版本的链接器。出现在输出分区定义之外的
表达式将所有数值视为绝对地址。出现在输出分区定义内的表达式将绝对符号视为数值。如果设置了
LD_FEATURES("SANE_EXPR")，绝对符号以及数值在任何地方都简单地被视为是数值，即绝对值。例
如： ::

    SECTIONS
    {
        . = 0x100;
        __executable_start = 0x100;
        .data :
        {
            . = 0x10;
            __data_start = 0x10;
            *(.data)
        }
        ...
    }

在前两个赋值中，点符号和 __executable_start 都被设置成绝对地址 0x100。在后面的两个赋值
中，点符号和 __data_start 被设置成相对于 .data 分区的数值 0x10。

如果一个表达式涉及数值、相对地址、以及绝对地址，链接器使用以下规则进行求值：

1. 如果操作数都是绝对地址或者数值，直接将这些值应用到操作符
2. 如果操作数中有一个是相对地址，并且对于二元操作，两个相对地址属于同一个分区或者操作的
   是一个相对地址和一个数值，那么应用到操作符的是地址的相对偏移部分
3. 其他二元操作，即两个不是同一分区的相对地址，或一个相对地址和一个绝对地址，首先将所有
   的非绝对地址转换成绝对地址，然后应用操作符

每个子表达式的结果遵循以下规则：

1. 仅涉及数值的操作结果都是数值
2. 任何比较，以及 && 和 || 也都是数值
3. 其他的算术和逻辑二元操作，两个同一分区的相对地址结果是数值；两个绝对地址（经过上述转
   换后）如果同一分区结果是数值，如果不是同一分区但是设置了 LD_FEATURES("SANE_EXPR")
   结果也是一个数值，否则是一个绝对地址
4. 其他的操作，同一分区的两个相对地址、或者一个相对地址和一个数值，结果是一个相对地址
5. 其他的操作，两个绝对地址（经过上述转换后）结果是一个绝对地址

可以使用内置函数 ABSOLUTE 强制一个表达式的结果为绝对值，例如创建一个绝对符号将 .data
输出分区的结束地址赋值给它： ::

    SECTIONS
    {
        .data : { *(.data) _edata = ABSOLUTE(.); }
    }

如果没有使用 ABSOLUTE，那么 _edata 的值将是一个相对于 .data 分区的符号，而不是一个绝对
地址。使用 LOADADDR 也可以强制一个表达式的结果为绝对值，因为这个特别的函数返回的式绝对
地址。

内置函数
--------

链接脚本语言包含了一系列可用于脚本表达式的内置函数：

ABSOLUTE(exp)
    返回表达式的绝对值（非负不可重定位），通常应用到分区定义内的符号，因为这种符号正常都
    是相对分区的相对值

ADDR(section)
    返回分区的虚拟内存地址（VMA），链接脚本必须已经定义了该分区的位置。例如下面的例子，
    symbol_1 的值是相对 .output1 分区的地址，而其他两个符号是绝对地址： ::

        SECTIONS {
            ...
            .output1 :
            {
                start_of_output_1 = ABSOLUTE(.);
                ...
            }
            .output :
            {
                symbol_1 = ADDR(.output1);
                symbol_2 = start_of_output_1;
            }
            ...
         }

ALIGN(align) ALIGN(exp, align)
    返回位置计数器或任意表达式对齐到下一个对齐边界。单参数的 ALIGN 不会改变位置计数器的
    值，它只对其进行算术运算。双参数的 ALIGN 允许任意表达式向上对齐，其中 ALIGN(align)
    相当于 ALIGN(ABSOLUTE(.), align)。下面的例子，它将 .data 输出分区对齐到前一分区之
    后的下一个 0x2000 字节边界，并在输入分区之后将其中的 variable 符号设置到下一个
    0x8000 边界： ::

        SECTIONS {
            ...
            .data ALIGN(0x2000): {
                *(.data)
                variable = ALIGN(0x8000);
            }
            ...
        }

    内置函数 NEXT 与 ALIGN 密切相关。

ALIGNOF(section)
    如果该分区已被分配返回命名分区的对齐字节数，如果分区未分配返回 0。如果分区在链接脚本
    中不存在，链接器会报错。如果分区是 NEXT_SECTION，那么返回链接脚本中指定的下一个已分
    配分区的对齐字节数，如果没有这样的分区返回 0。下面的例子中，.output 分区的对齐字节
    数被保存在该分区的第一个值中： ::

        SECTIONS{
            ...
            .output {
                LONG (ALIGNOF(.output))
                ...
            }
            ...
        }

BLOCK(exp)
    与 ALIGN 相同，为了与旧链接脚本兼容，常常用来设置输出分区的地址

DATA_SEGMENT_ALIGN(maxpagesize, commonpagesize)
    maxpagesize 为最大内存页大小，commonpagesize 为默认内存页大小，等价于： ::

        (ALIGN(maxpagesize) + (. & (maxpagesize - 1)))
        或者
        (ALIGN(maxpagesize) + ((. + commonpagesize - 1) & (maxpagesize - commonpagesize)))

    使用哪种形式，取决于后者比前者使用较少的 commonpagesize 大小的页面来为数据段分配内
    存，如果是则使用后者。这个数据段表示的是 DATA_SEGMENT_ALIGN 与 DATA_SEGMENT_END
    之间的区域。如果使用后一种形式，在运行时节省 commonpagesize 字节的内存，代价是在磁
    盘文件中最多浪费 commonpagesize 字节。

    这个表达式只能直接用在链接脚本的 SECTIONS 命令中，不能再任何输出分区描述中使用，且
    在连接脚本中只能使用一次。commonpagesize 应该小于等于 maxpagesize，并且应该是目标
    在运行时想要优化的系统页面大小，同时仍然可以在页面大小达到 maxpagesize 的情况下运
    行。但注意，如果系统页面大小大于 commonpagesize，选项 -z relro 保护将不会生效。例
    如： ::

        . = DATA_SEGMENT_ALIGN(0x10000, 0x2000);

DATA_SEGMENT_END(exp)
    为 DATA_SEGMENT_ALIGN 定义数据段的结束点，例如： ::

        . = DATA_SEGMENT_END(.);

DATA_SEGMENT_RELRO_END(offset, exp)
    当设置了命令行选项 -z relro，该函数定义 PT_GNU_RELRO 分段的结束点。如果 -z relro
    选择不存在，该函数不做任何事。否则，DATA_SEGMENT_ALIGN 被填补使得 exp + offset 对
    齐到 commonpagesize。如果存在该函数，必须位于 DATA_SEGMENT_ALIGN 和 DATA_SEGMENT_END
    两个函数之间。对第二个参数的求值需要加上 PT_GNU_RELRO 分段之后的由于分区对齐的填补
    字节。例如： ::

        . = DATA_SEGMENT_RELRO_END(24, .);

DEFINED(symbol)
    如果符号是链接器全局符号表中的符号，并且在该函数调用语句之前有定义，返回 1，否则返回
    0。例如下面的例子，如果 begin 已经定义保留原来的值，否则定义为当前的位置计数： ::

        SECTIONS {
            ...
            .text : {
                begin = DEFINED(begin) ? begin : . ;
                ...
            }
            ...
        }

LENGTH(memory)
    返回内存区域的长度

LOADADDR(section)
    返回命名分区的绝对加载地址（LMA）

LOG2CEIL(exp)
    返回向上取整的对数值，LOG2CEIL(0) 返回 0

MAX(exp1, exp2)
    返回最大值

MIN(exp1, exp2)
    返回最小值

NEXT(exp)
    返回下一个未分配的 exp 整数倍的地址，这个函数与 ALIGN(exp) 密切相关，除非使用 MEMORY
    命令给目标文件定义了一个不连续内存，这种情况下两个函数是等价的

ORIGIN(memory)
    返回内存区域的起始点

SEGMENT_START(segment, default)
    返回命名分段的基地址，如果显式使用了 -T<section> 命令行选项为该段设置了基地址则返
    回这个值，否则返回 default 值。目前， -T<section> 选项仅用来为 text、data、bss
    等分区设置基地址（例如 -Ttext=org），但是 SEGMENT_START 可以传入任何分段名称

SIZEOF(section)
    如果分区是一个已经分配的分区返回命名分区的字节大小，否则返回 0。如果分区在链接脚本中
    不存在，链接器会报错。如果分区是 NEXT_SECTION，返回链接脚本中指定的下一个已分配分区
    的字节大小，如果不存在这样的分区返回 0。例如，下面两个符号 symbol_1 和 symbol_2 的
    值相同： ::

        SECTIONS{
            ...
            .output {
                .start = . ;
                ...
                .end = . ;
            }
            symbol_1 = .end - .start ;
            symbol_2 = SIZEOF(.output);
            ...
        }

SIZEOF_HEADERS
    返回输出文件的头部字节大小，这些头部信息出现在输出文件的开始部分。可以使用这个值来设
    置第一个分区的起始地址，以便于分页。当生成 ELF 格式文件时，如果链接脚本使用该函数，
    链接必须在确定所有分区地址和大小之前计算程序头部的大小。如果链接器后来发现它需要一个
    额外的程序头部，将报一个 not enough room for program headers 的错误。为了避免这个
    错误，就要避免使用这个函数，或者重新设计链接脚本以避免强迫链接器使用额外的程序头部，
    或者必须使用 PHDRS 命令定义自己的程序头部。
