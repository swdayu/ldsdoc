脚本命令
=========

* `MEMORY 命令`_
* `PHDRS 命令`_
* `VERSION 命令`_
* `SECTIONS 命令`_
* `输出分区属性`_
* `重叠分区描述`_
* `输出分区数据`_
* `输入分区描述`_
* `包含通用符号`_
* `输入分区匹配`_

MEMORY 命令
------------

链接器默认配置允许分配所有可用的内存，可以使用 MEMORY 命令改变这个行为。MEMORY 命令描述
目标平台上内存区域的大小和位置。可以使用该命令描述使用哪些内存区域，并避免使用哪些内存区
域。然后，可以将分区分配到特定的内存区域。链接器会根据内存区域分配分区的地址，并且当内存
区域被占满时报警告。链接器不会为了适应可用内存区域而重新排列分区。

链接脚本可以包含多个 MEMORY 命令，然而所有这 MEMORY 命令定义的内存区域就像定义在单个命
令中一样。该命令的语法如下： ::

    MEMORY {
        name [(attr)] : ORIGIN = origin, LENGTH = len
        ...
    }

其中 name 是用来在链接脚本中引用这个内存区域的名字，区域的名字在链接脚本之外没有意义。区
域的名字保存在分隔的名字空间中，不会与符号名、文件名、分区名冲突。每个内存区域在 MEMORY
命令中必须有一个确定唯一的名字，但是可以 REGION_ALIAS 命令定义内存区域的别名。

属性字符串 attr 是一个可选的属性列表，表示在链接脚本中没有显式映射的输入分区，是否可以保
存到一个特定区域中。在 SECTIONS 命令描述的那样，如果没有给一些输入分区指定输出分区，这些
输入分区被称为是孤立分区，链接器会自动创建一个同名的输出分区来保存孤立分区。如果为内存区
域定义了区域属性，链接器可以使用它们来选择一个内存区域给它创建的输出分区使用。attr 只能
包含以下字符： ::

    R   只读分区
    W   可读写分区
    X   可执行分区
    A   可分配分区
    I   初始化分区
    L   与 I 相同
    !   后面属性的相反含义

如果一个未映射的分区匹配区域属性列表中任何一个并且没有 ! 属性指定的属性，它会被放置到这
个内存区域。例如 RW!X 可以匹配有任何一个 R 或 W 属性并且不包含 X 属性的未映射分区。

参数 origin 是一个数值表达式，指定内存区域的起始地址。这个表达式的求值结果必须式常量，并
且不能引用任何符号。关键字 ORIGIN 可以略写为 org 或者 o，但不能是例如 ORG 等。参数 len
表示内存区域的字节大小，跟 origin 表达式一样必须是数值常量。关键字 LENGTH 可以略写为
len 或者 l。下面的例子，指定了两个可以用来分配的内存区域，一个从地址 0 开始，长度 256K，
一个从地址 0x40000000 开始，长度 4M。链接器会自动将未显式指定内存区域的只读或可执行分区
分配到 rom 内存区域，并将其他类型的未显式指定内存区域的分区分配到 ram 内存区域。 ::

    MEMORY
    {
        rom (rx) : ORIGIN = 0, LENGTH = 256K
        ram (!rx) : org = 0x40000000, l = 4M
    }

定义内存区域之后，可以使用 ``>region`` 输出分区属性让链接器将该分区分配到对应的内存区域
中。例如有一个名为 mem 的内存区域，可以在输出分区定义中使用 ``>mem`` 分区属性。如果输出
分区没有指定地址，链接器会将分区地址设置为指定的内存区域中下一个可用的地址，如果包含的分
区超过了内存区域的大小，链接器会报错。

在表达式中，可以使用 ORIGIN(memory) 和 LENGTH(memory) 来访问内存区域的起始地址和字节
长度。例如： ::

    _fstack = ORIGIN(ram) + LENGTH(ram) - 4;

PHDRS 命令
-----------

ELF 目标格式文件使用了程序头部，或者称为分段。程序头部描述了程序怎么加载到内存中。可以使
用 objdump -p 打印程序头部信息。在 ELF 本地平台上执行一个 ELF 程序时，系统加载器会读取
程序头部来决定怎么加载程序。这只有在程序头部信息被正确设置是才能工作。这里不会介绍系统加
载器解释程序头部的细节，详情参考 ELF ABI 文档。

链接器默认会创建合适的程序头部，但是在以下情况，可能需要更精确的指定程序头部。那就可以使
用 PHDRS 命令。当链接器在链接脚本中看到这个命令时，它不会创建任何没有指定的程序头部。只
有在生成 ELF 格式的输出文件时，才注意 PHDRS 命令，其他格式会忽略该命令。

下面是 PHDRS 命令的语法，其中 PHDRS、FILEHDR、AT、FLAGS 是关键字： ::

    PHDRS
    {
        name type [FILEHDR] [PHDRS] [AT(address)] [FLAGS(flags)];
    }

其中 name 是程序头部名称，只能在链接脚本中的 SECITONS 命令中引用，它不会被保存到输出文
件中。程序头部名称保存在隔离的名字空间中，不会与符号名、文件名、分区名冲突。每个程序头部
必须有一个确定唯一的名称。程序头部会被顺序的处理，通常会按升序加载地址的顺序映射到分区。

参数 type 表示程序头部的类型，可以是下面值中的一个： ::

    PT_NULL     0   表示未使用的程序头部
    PT_LOAD     1   表示这个程序头部描述的是一个需要从文件加载的分段
    PT_DYNAMIC  2   是一个动态链接信息分段
    PT_INTERP   3   是一个程序解释器分段
    PT_NOTE     4   是一个说明信息分段
    PT_SHLIB    5   是一个预留分段，其定义未指定
    PT_PHDR     6   是一个程序头部列表分段
    PT_TLS      7   表示包括 TLS 的分段
    expression      用来表示程序头部数值类型的表达式，可以表示没有在上面定义的类型

某些程序头部类型用来描述，系统加载器将从文件加载的内存段。在链接脚本中，通过在分段中指定
可分配的输出分区为这些分段指定内容。可以使用 :phdr 输出分区属性将一个分区放置到特定的分
段中。如果使用 :phdr 将分区放置到一个或多个分段中，链接器会把所有后续未指定 :phdr 的可
分配分区都放置到相同的分段中。这是为了方便，因为通常一组连续的分区将被放置到单个分段中。
可以使用 :NONE 来覆盖默认段，并告诉链接器不讲分区放到任何段中。

可以在程序头部类型之后使用 FILEHDR 和 PHDRS 关键字来进一步描述段的内容。FILEHDR 关键字
表示该段应该包含 ELF 文件头部。PHDRS 关键字表示该段应该包含 ELF 程序头部本身。如果应用
于可加载段（PT_LOAD），则所有前面的可加载段必须具有这两个关键字之一。

还可以使用 AT 表达式指定一个分段应该加载到一个特定的内存地址位置。这等价于作为输出分区属
性使用的 AT 命令。程序头部的 AT 命令会覆盖输出分区属性。链接器会根据组成段的分区来设置
段的标记。也可以通过 FLAGS 关键字显式指定分段标记，flags 的值必须是一个整数，它用来设置
程序头部结构体中的 p_flags 字段。

下面是一个 PHDRS 的例子，展示了一个典型的本地 ELF 平台上使用的程序头部集合： ::

    PHDRS
    {
        headers PT_PHDR PHDRS ;
        interp PT_INTERP ;
        text PT_LOAD FILEHDR PHDRS ;
        data PT_LOAD ;
        dynamic PT_DYNAMIC ;
    }

    SECTIONS
    {
        . = SIZEOF_HEADERS;
        .interp : { *(.interp) } :text :interp
        .text : { *(.text) } :text
        .rodata : { *(.rodata) } /* defaults to :text */
        ...
        . = . + 0x1000; /* move to a new page in memory */
        .data : { *(.data) } :data
        .dynamic : { *(.dynamic) } :data :dynamic
        ...
    }

VERSION 命令
-------------

当使用 ELF 时，链接器支持符号版本，符号版本仅在共享库中有用。当动态链接器运行一个可能链
接了一个更早版本的共享库的程序时，可以使用符号版本来选择指定版本的函数。可以在主链接脚本
中直接包含一个 VERSION，或者提供一个 VERSION 脚本作为隐式的链接脚本，还可以使用命令行选
项 --version-script 来指定。VERSION 命令的语法如下： ::

    VERSION { version-script-commands }

版本脚本命令的格式与 Solaris 2.5 中的 Sun 链接器使用的相同。版本脚本定义了一个版本节点
树，可以在版本脚本中指定节点名称以及内部依赖。可以指定哪个符号绑定到哪个版本节点，并且可
以将指定的一组符号限定到局部作用域，使它们在共享库外不可见。版本脚本语言的例子： ::

    VERS_1.1 {
        global:
            foo1;
        local:
            old*;
            original*;
            new*;
    };

    VERS_1.2 {
        foo2;
    } VERS_1.1;

    VERS_2.0 {
        bar1; bar2;
        extern "C++" {
            ns::*;
            "f(int, double)";
        };
    } VERS_1.2;

其中定义了三个版本节点，第一个是 VERS_1.1，它没有其他依赖，绑定了符号 foo1 到 VERS_1.1，
然后将以 old、original、new 开始的符号定义为局部作用域符号。如果符号名称指定在双引号内，
不会解析成通配符，而是将字面字符串当作符号名称。接着定义了 VERS_1.2，它依赖于 VERS_1.1，
绑定了符号 foo2 到 VERS_1.2 版本节点中。最后定义了 VERS_2.0，依赖 VERS_1.2，绑定了符
号 bar1 和 bar2。

还可以在版本脚本中指定高级语言对应的符号： ::

    VERSION extern "lang" { version-script-commands }

其中支持的 lang 可以是 C、C++、Java，默认的 lang 是 C，链接器会在链接时遍历符号列表，
并根据 lang 脱去符号的名称装饰（demangling），然后再将它们与版本脚本命令中指定的模式进
行匹配。脱去装饰的符号名称可能包含空格和其他特殊字符（因为是函数签名），你可以用如下所述
的全局模式匹配这些名称，或者使用双引号字符串进行精确匹配。在后一种情况下，要注意版本脚本
和脱去状态的名称之间的微小差异，例如不同的空格，会导致不匹配。由于脱装饰生成的确切字符串
将来可能会改变，即使名称的装饰没改变，在升级版本时都应该检查所有版本命令按预期行为工作。

当链接器找到一个库中定义的但没有绑定到版本节点的符号，实际上会将其绑定到库的一个未指定的
基础版本上。可以通过在版本脚本中某个位置使用 ``global: *;`` 来将所有未绑定的符号绑定到
给定的版本节点。注意，除了最后一个版本节点，在其他节点中使用全局规范通配符都是不太合适的，
因为可能会意外将符号添加到旧版本的导出集中。这是错误的，因为旧版本应该具有一组固定的符号。

版本节点的名称除了用于阅读，没有特别的意义。并且 VERS_2.0 完全可以出现在 VERS_1.1 和
VERS_1.2 之间，但是比较使人困惑。如果一个版本节点是版本脚本中唯一的版本，可以省略节点的
名称，这样版本脚本不会未符号分配任何版本，只会选择其中全局作用域可见的符号。例如： ::

    { global: foo; bar; local: *; };

当一个应用程序链接一个有版本信息符号的共享库时，应用程序自己知道需要哪个版本的符号，也知
道它链接的每个共享库中的版本节点。因此在运行时，动态链接器可以快速检测链接的库确实提供了
应用程序需要解析所有动态符号的所有版本节点。通过这种方式，动态链接器可以确定所有它需要的
外部符号都是可解析的，而无需搜索每个符号引用。

符号版本化实际上是 SunOS 进行次要版本检查的一种更为复杂的方式。这里要解决的根本问题是，
通常对外部函数的引用是按需绑定的，并不是在应用程序启动时全部绑定。如果共享库过时了，可能
缺少所需的接口，当应用程序尝试使用该接口时，它可能会突然意外的失败。有了符号版本化，如果
与应用程序一起使用的库太旧，用户在启动程序时就会收到警告。有几个 GNU 对 Sun 版本化方法
的扩展。首先时能够在定义符号的源文件中将符号绑定到版本节点，而不是在版本脚本中，这样做主
要是为了减轻库维护者的负担。例如将函数 original_foo 重命名为一个别名 foo，并将它绑定到
VERS_1.1，并且可以使用 local: 防止导出 original_foo 符号： ::

    __asm__(".symver original_foo,foo@VERS_1.1");

命令 .symver 优先级高于版本脚本中定义的内容。GNU 的第二个扩展是允许同一个函数的多个版本
出现在一个给定的共享库中。这样可以在不增加共享库的主版本的情况下，对接口进行不兼容的更改，
同时仍然允许链接到旧接口的应用程序继续运行。使用多个 .symver 命令可以达到这个目的： ::

    __asm__(".symver original_foo,foo@");
    __asm__(".symver old_foo,foo@VERS_1.1");
    __asm__(".symver old_foo1,foo@VERS_1.2");
    __asm__(".symver new_foo,foo@@VERS_2.0");

其中 foo@ 表示符号 foo 绑定到未指定的基础版本。这个例子包含四个 C 函数 original_foo、
old_foo、old_foo1、new_foo。当一个符号有多个定义时，需要有一种方法来指定外部引用将绑定
到的默认版本。可以使用 foo@@VERS_2.0 的形式做到这一点，只能使用这个方式声明一个符号的版
本为默认版本，否则该符号的默认版本有多个定义。

SECTIONS 命令
--------------

SECTIONS 命令用于告诉链接器怎样将输入分区映射到输出分区中，并且怎样将输出文件放置到内存
区域中。SECTIONS 命令的语法如下： ::

    SECTIONS
    {
        sections-command
        sections-command
        ...
    }

每条分区命令可以是：

1. 一个 ENTRY 命令
2. 一个符号赋值
3. 一个输出分区描述
4. 一个重叠分区（overlay）描述

如果在链接脚本中没有使用 SECTIONS 命令，链接器将按输入文件中第一次遇到的输入分区名称的
顺序，将每个输入分区放置到同名的输出分区中。例如，如果所有输入分区都在第一个文件中，则输
出分区中的分区顺序将与第一个输入文件中的分区顺序匹配，且第一个输出分区将位于地址零处。

输出分区描述的完整语法如下，但是大多数输出分区不会使用大多数的可选分区属性： ::

    section [address] [(type)] :
        [AT(lma)]
        [ALIGN(section_align) | ALIGN_WITH_INPUT]
        [SUBALIGN(subsection_align)]
        [constraint]
        {
            output-section-command
            output-section-command
            ...
        } [>region] [AT>lma_region] [:phdr :phdr ...] [=fillexp] [,]

分区名称 section 周围需要使用空白，使得分区名称是明确不混淆的，冒号和大括号也是必须的。
如果使用了 fillexp，并且下一个 SECTIONS 命令看起来像是表达式的延续，那么必须在当前命令
结尾加上逗号。而换行和其他空白字符是可选的。

其中的输出分区命令可以是：

1. 一个符号赋值
2. 一个输入分区描述
3. 直接包含数据值，见 `输出分区数据`_

输出分区名称 section 必须满足输出目标文件格式的规定。在只支持有限数量分区的格式中，例如
a.out，名称必须是格式支持的名称之一（a.out 只允许 .text、.data、或 .bss 分区）。如果
输出格式支持任意数量的分区，但是使用数字而不是名称（例如 Oasys），名称应该使用带双引号的
数字字符串表示。分区名称可以由任何字符序列组成，但如果包含特殊字符（如逗号），必须使用双
引用形式表示分区名称。但是，名称 "/DISCARD/" 是一个特殊的输出分区名。

输出分区的地址 address 是一个表示虚拟内存地址（VMA）的表达式。地址是可选的，但如果提供
了那么输出分区的地址确切地设定为指定的值。如果没有指定地址，会尝试以下步骤来为分区选择一
个地址。这个地址会被调整到适合分区对齐要求的边界上，输出分区的对齐要求是所有输入分区中最
严的那个对齐要求。

1. 如果为该分区设置了一个内存区域，该分区会被添加到这区域，分区的地址是区域中下一个可用
   的地址
2. 如果使用 MEMORY 命令创建了一个内存区域列表，第一个区域属性与分区兼容的区域被用来保存
   这个分区，分区的地址是区域中下一个可用的地址
3. 如果没有内存区域，或者没有匹配的内存区域，那么分区的地址会基于当前的位置计数确定

例如： ::

    .text . : { *(.text) }
    .text : { *(.text) }

第一个使用当前的位置计数作为分区的地址，第二个基于当前位置计数并对齐到分区对齐要求边界的
地址作为分区地址。地址 address 可以是一个任意的表达式，例如，如果像对齐到 0x10 字节边界，
地址的低4比特必须为零，你可以这样设置分区地址： ::

    .text ALIGN(0x10) : { *(.text) }

这样能工作工作是因为 ALIGN 返回的是基于当前位置计数并满足对齐要求的地址。给一个非空分区
指定地址会改变位置计数器的值，空分区会被忽略。

每个分区可以指定一个类型，类型是包含在括号内的关键字，定义的类型如下：

NOLOAD
    分区不可加载，即分区不会在程序运行时加载到内存
READONLY
    只读分区
DSECT COPY INFO OVERLAY
    仅为了兼容旧版本而存在，表示分区不需要分配，即当程序运行时不需要为该分区分配内存
TYPE = type
    将分区类型设定为一个整数类型。在生成 ELF 目标格式文件时，可以使用这些类型名称 SHT_PROGBITS、
    SHT_STRTAB、SHT_NOTE、SHT_NOBITS、SHT_INIT_ARRAY、SHT_FINI_ARRAY、SHT_PREINIT_ARRAY。
    用户需要负责确保分区类型的任何特殊需求都必须满足。注意的是，只有当分区包含的内容或部
    分内容没有自己隐式类型时才使用 TYPE 指定的类型，否则使用内容的隐式类型。例如： ::

        .foo . TYPE = SHT_PROGBITS { *(.bar) }
        .foo . TYPE = SHT_PROGBITS { BYTE(1) }
        .foo . TYPE = SHT_PROGBITS { BYTE(1); *(.bar) }

    第一个分区的类型是输入分区 .bar 的类型，可能不是 SHT_PROGBITS；第二个分区的类型是
    SHT_PROGBITS；第三个分区的类型是 SHT_PROGBITS。
READONLY(TYPE = type)
    是对应的类型并且是只读的

链接器正常会基于输入分区属性来设置输出分区的属性，显式指定上面的类型可以覆盖这个行为。例
如，下面的链接脚本，ROM 分区从地址 0 开始并且不需要加载： ::

    SECTIONS {
        ROM 0 (NOLOAD) : { ... }
        ...
    }

链接器通常不会创建没有内容的输出分区，为了方便可以在输入分区描述中包含可能存在也可能不存
在的输入分区。例如： ::

    .foo : { *(.foo) }

只有在至少一个输入文件中有一个 .foo 分区，并且输入分区不为空时，才会在输出文件中创建一个
输出分区 .foo。其他在输出分区中分配空间的链接脚本也会产生输出分区。即使是对当前位置计数
的赋值，除非赋值不创建空间，也会创建输出分区。这允许 ``. = .`` 强制输出一个空分区。但以
下赋值不会创建空间： ::

    . = 0
    . = . + 0
    . = sym /* sym 是脚本中定义为 0 的绝对值符号 */
    . = . + sym
    . = ALIGN(. != 0 ? expr : 1)

链接器会忽略对丢弃输出分区地址的赋值，除非链接脚本在这个分区中定义了符号。这种情况下，链
接器会遵守地址赋值，即使分区被丢弃了也可能增加当前位置计数。

可以使用特殊的输出分区 "/DISCARD/" 来丢弃输入分区，任何被分配到该分区的输入分区都不会包
含到输出文件中。这可以用来丢弃使用 ELF 标记 SF_GNU_RETAIN 标记的输入分区，否则这些分区
会从链接器垃圾回收中保存下来。注意，匹配 "/DISCARD/" 名的输出分区将被丢弃，即使它们属于
一个 ELF 分区分组且这个分区分组还包含不被丢弃的成员分区。这是故意的，丢弃优先于分组。

输出分区属性
------------

这里介绍输出分区描述中大括号之前和之后的分区属性： ::

    ... :
    [AT(lma)]
    [ALIGN(section_align) | ALIGN_WITH_INPUT]
    [SUBALIGN(subsection_align)]
    [constraint]
    {
        ...
    } [>region] [AT>lma_region] [:phdr :phdr ...] [=fillexp] [,]

**加载地址**

每个分区都有一个虚拟内存地址（VMA）和一个加载地址（LMA），虚拟内存地址通过输出分区的地址
指定，而加载地址通过分区属性 AT(lma) 或 AT>lma_region 关键字来指定。指定一个加载地址是
可选的。

AT 关键字接受一个表达式作为参数，指定确切的分区加载地址。而 AT> 关键字接受一个内存区域
作为参数，分区的加载地址设定为给区域下一个可用地址，并对齐到分区的要求的对齐边界。一个可
分配分区，如果既没有使用 AT 也没有使用 AT> 指定加载地址，链接器会使用下面的规则确定加载
地址：

1. 如果分区指定了虚拟内存地址（VMA），使用该地址作为加载地址（LMA）
2. 如果分区是不分配的，它的加载地址被设定为它的虚拟地址
3. 否则，如果可以找到一个与当前分区兼容的内存区域，并且该区域包含至少一个分区，那么加载
   地址会被设定到这个区域，并且它的 VMA 与 LMA 之间的差异与区域中最后一个分区的 VMA 与
   LMA 之间的差异相同
4. 如果没有声明的内存区域，则使用覆盖整个地址空间的默认区域按照上一步骤设定加载地址
5. 如果没有找到合适的内存区域，或者区域中没有前一个输出分区，使用虚拟地址作为加载地址

设置加载地址是为了方便创建 ROM 映像。例如，下面的链接脚本创建了三个输出分区：.text 起始
虚拟地址 0x1000；.mdata 起始虚拟地址 0x2000，加载地址是 .text 分区结尾的地址；.bss 起
始虚拟地址 0x3000。符号 _data 的值是 0x2000，当前位置计数保存的是虚拟地址。 ::

    SECTIONS
    {
        .text 0x1000 :
        {
            *(.text) _etext = . ;
        }
        .mdata 0x2000 :
            AT(ADDR(.text) + SIZEOF(.text))
        {
            _data = . ;
            *(.data);
            _edata = . ;
        }
        .bss 0x3000 :
        {
            _bstart = . ;
            *(.bss) *(COMMON) ;
            _bend = . ;
        }
    }

与该链接脚本生成的程序一起使用的运行时初始化代码将包含以下类似的内容，会将 ROM 映像中初
始化数据拷贝到对应的运行时地址。注意这段代码是如何利用链接脚本中定义的符号的。 ::

    extern char _etext, _data, _edata, _bstart, _bend;
    char *src = &_etext; // .mdata 的加载地址
    char *dst = &_data;  // .mdata 的虚拟地址

    while (dst < &_edata)
        *dst++ = *src++; // 将 .mdata 分区内容从加载地址拷贝到虚拟地址

    for (dst = &_bstart; dst< &_bend; dst++)
        *dst = 0; // 将 .bss 分区置为 0

**对齐和约束**

使用 ALIGN(section_align) 可以指定分区的对齐字节数。也可以使用 ALIGN_WITH_INPUT 属性
保证该输出分区中，虚拟内存地址（VMA）和加载地址（LMA）之间的差异与输入分区保持不变。而使
用 SUBALIGN(subsection_align) 可以指定该输出分区中每个输入分区的对齐字节要求，这个值会
覆盖输入分区中给定的对齐字节，不管是大还是小。

可以使用 ONLY_IF_RO 以及 ONLY_IF_RW 约束，来指定只有在所有输入分区都是只读或者都是可读
可写的时候，才创建输出分区。

**内存区域**

可以使用 ``>region`` 属性为输出分区指定一个预先定义的内存区域，该方法是指定输出分区虚拟
地址的另一种方式。例如： ::

    MEMORY { rom : ORIGIN = 0x1000, LENGTH = 0x1000 }
    SECTIONS { ROM : { *(.text) } >rom }

**程序头部**

使用 ``:phdr`` 可以将输出分区赋给一个预先定义的程序头部对应的分段。如果一个分区赋给了一
个或多个分段，表示后续的输出分区也会被分配到这些分段中，除非它们使用了一个明确的 ``:phdr``
修饰符，或者使用 ``:NONE`` 告诉链接器不要将该输出分区放到任何分段中。一个例子： ::

    PHDRS { text PT_LOAD ; }
    SECTIONS { .text : { *(.text) } :text }

**填充**

可以使用 ``=fillexp`` 指定的表达式值来填充整个分区中所有未指定的内存区域，包括由于输入
分区对齐而留下的空隙，必要时重复使用。如果填充表达式是一个简单的十六进制数，即以 0x 开头
且末尾没有 K 或者 M 的十六进制字串，则可以使用任意长的十六进制字串，前导零也会成为填充
模式的一部分。对于所有其他情况，包括额外的括号或者一元 +，填充模式是表达式值得四个最低有
效字节。如果该值小于四个字节，则会使用零扩展到四个字节。在所有情况下，该填充值都是用大端
字节序填充到内存区域中。例如： ::

    值          内存区域
    0x90        90 90 90 90
    0x0090      00 90 00 90
    144         00 00 00 90

但是可以在输出分区描述的内容中，使用 FILL 命令修改这个填充字节。一个填充的例子： ::

    SECTIONS { .text : { *(.text) } =0x90909090 }

重叠分区描述
-------------

重叠分区描述提供了一种简便的方法，用来描述加载到同一内存映像中的多个分区，需要在相同的内
存地址处执行。在运行时，重叠分区管理器会根据需要将重叠的分区拷贝到或拷贝出内存，可能只需
要简单地通过操作地址就可以实现这个功能。这种方法，在一些情况例如系统中的某些内存区域比另
一个内存区域运行速度更快时非常有用。

重叠分区通过使用 OVERLAY 命令来描述，该命令只能使用在 SECTIONS 命令中，并且跟输出分区
描述的语言很像。OVERLAY 命令完整的语法如下： ::

    OVERLAY [start] : [NOCROSSREFS] [AT(ldaddr)]
    {
        secname1
        {
            output-section-command
            output-section-command
            ...
        } [:phdr...] [=fill]
        secname2
        {
            output-section-command
            output-section-command
            ...
        } [:phdr...] [=fill]
        ...
    } [>region] [:phdr...] [=fill] [,]

除了 OVERLAY 关键字外，其他都是可选的，但是每个分区都必须有一个名称（例如上面的 secname1
和 secname2）。OVERLAY 结构内部的分区定义域一般的 SECTIONS 内的定义相同，只是 OVERLAY
内的分区不能定义地址和内存区域。如果使用了填充，并且下一个 SECTIONS 命令看起来像是表达
式的延续，那么末尾可能需要加一个逗号。

分区都定义有相同的起始地址，分区的加载地址被设置为从 OVERLAY 整体使用的加载地址开始，按
顺序依次排列对应的地址。与普通分区定义一样，OVERLAY 的加载地址 AT(ldaddr) 是可选的，默
认是起始地址，起始地址也是可选的，默认为位置计数的当前值。如果使用了 NOCROSSREFS 关键字，
其中的任何分区之间都不能存在引用，否则链接器会报错。这是因为，其中的分区时重叠的，都会在
相同的地址运行，它们的执行是分时错开的不可能同时存在，因此一个分区引用其他分区定义的内容
没有意义。

对于 OVERLAY 中的每个分区，链接器自动提供了两个符号，其中 __load_start_secname 定义为
分区的起始加载地址，符号 __load_stop_secname 定义为分区的最终加载地址。secname 中的任
何字符如果不是 C 标识符中的合法字符，会被移除。C 或者汇编代码可以使用这些符号按需移动重
叠的分区。在重叠末尾，位置计数的值会被设置为重叠的起始地址加上其中最大分区的大小。

下面是一个例子，注意这些内容需要出现在 SECTIONS 命令内部： ::

    OVERLAY 0x1000 : AT(0x4000)
    {
        .text0 { o1/*.o(.text) }
        .text1 { o2/*.o(.text) }
    }

其中定义了 .text0 和 .text1 两个分区的起始地址都是 0x1000，.text0 会被加载到 0x4000，
.text1 会被加载到 .text0 分区之后。并且定义了以下符号：__load_start_text0，__load_stop_text0，
__load_start_text1，__load_stop_text1。C 语言可以使用下面的代码将 .text1 分区拷贝到
重叠的内存区域： ::

    extern char __load_start_text1, __load_stop_text1;
    memcpy ((char*)0x1000, &__load_start_text1, &__load_stop_text1 - &__load_start_text1);

注意的是，OVERLAY 命令仅仅是一个语法糖，它可以使用更基本的命令来完成。例如上面的例子完全
可以用下面的脚本实现： ::

    .text0 0x1000 : AT (0x4000) { o1/*.o(.text) }
    PROVIDE (__load_start_text0 = LOADADDR (.text0));
    PROVIDE (__load_stop_text0 = LOADADDR (.text0) + SIZEOF (.text0));
    .text1 0x1000 : AT (0x4000 + SIZEOF (.text0)) { o2/*.o(.text) }
    PROVIDE (__load_start_text1 = LOADADDR (.text1));
    PROVIDE (__load_stop_text1 = LOADADDR (.text1) + SIZEOF (.text1));
    . = 0x1000 + MAX (SIZEOF (.text0), SIZEOF (.text1));

输出分区数据
------------

可以在输出分区中使用 BYTE、SHORT、LONG、QUAD、或者 SQUAD 直接在分区中包含数据。每个关
键字都使用一个包含在括号内的表达式作为参数，表示需要存储在分区中的值。这些值会保存到分区
中当前的位置计数的位置。这些关键字分别保存一个、两个、四个、八个字节数据，并且位置计数会
增加相对应的字节。例如保存一个字节再继续保存符号 addr 表示的地址数据： ::

    BYTE(1)
    LONG(addr)

当主机或目标平台是64位时，QUAD 和 SQUAD 相同，都是八个字节。当主机和目标平台都是32位时，
表达式会计算为32位结果，QUAD 会保存32位值并使用零比特扩展到64位，SQUAD 会保存32位值并
将符号位扩展到64位。

如果目标文件的文件格式有显式的字节序，通常都会有，值会以这种字节序进行保存。如果目标格式
没有显式字节序，值会根据第一个输入目标文件的字节序保存。

还可以使用 ASCIZ 关键字包含以零字符结束的字符串。如果字符串中包含有空格，必须包含再双引
号中，字符串可以包含 \n、\r、\t、以及八进制数字，十六进制数字不支持。例如，下面会创建一
个包含 17 个字节的区域： ::

    ASCIZ "This is 16 bytes"

注意的时，这些关键字只能在输出分区描述内部有效，在外部时无效的。下面第一个会导致链接器报
错，而第二个是有效的： ::

    SECTIONS { .text : { *(.text) } LONG(1) .data : { *(.data) } }
    SECTIONS { .text : { *(.text) ; LONG(1) } .data : { *(.data) } }

还可以使用 FILL 命令设置当前分区的填充模式，它接受包含在括号内的一个表达式作为参数。分区
内任何未指定的区域（例如输入分区因对留下的空隙）都会重复的填充这个表达式对应的值。该命令
可以影响该分区之后的内存位置，通过使用多个 FILL 命令，可以给分区不同位置指定不同的填充
模式。该命令的例子： ::

    FILL(0x90909090)

FILL 命令与分区属性 ``=fillexp`` 类似，但是之影响该命令之后的部分区域，而不是整个区域。
如果两种方式都指定了，FILL 命令的优先级高。

注意在正常情况下，表达式的值会通过零扩展将值扩展到4个字节。因此 FILL(144) 会重复填充的
字节是 0 0 0 144。这个值会用大端字节序进行填充，例如 FILL(22*256 + 23) 对应的重复填充
字节是 0 0 22 23。如果一个表达式的值大于4个字节，只使用最低的4字节。但是如果表达式是一
个十六进制数，上面的规则就不适用。这种情况下，不会进行零扩展，会使用十六进制数种的所有字
节，并且前置零也是重要的不会忽略。例如 FILL(0x90) 会重复填充 0x90，FILL(0x9192) 会重
复填充 0x91 0x92，FILL(0x0090) 会重复填充 0x00 0x90，FILL(0x123456789a) 会重复填充
0x12 0x34 0x56 0x78 0x9a。十六进制数这种填充规则只适用于 0x[0-9][a-f][A-F] 这种形式
的十六进制数，而使用 $ 前缀或者 h、H、x、X 后缀的十六进制数还是使用正常规则，而且包含十
六进制数的多操作数表达式也是使用正常规则。

使用 LINKER_VERSION 命令可以在当前位置计数位置插入一个包含链接器版本的字符串。但是默认
情况下，该命令是没有打开的不会做任何事情。只有提供命令行选项 --enable-linker-version
才能激活这个命令。基于 ELF 目标格式的内置链接脚本已经在 .comment 分区种包含了这条命令。

在输出分区中，关键字 CREATE_OBJECT_SYMBOLS 和 CONSTRUCTORS 可以作为输出分区命令使用。
其中 CREATE_OBJECT_SYMBOLS 命令告诉链接器为每一个输入文件创建一个符号，符号的名称是对
应输入文件名。符号基于的输出分区是该命令所处的分区。这是 a.out 目标文件格式的惯例用法，
其他目标格式文件通常不使用。

在使用 a.out 对象文件格式进行链接时，链接器使用一种不寻常的结构支持 C++ 全局构造函数和
析构函数。当目标文件格式不支持任意名称的分区时，例如 ECOFF 和 XCOFF，链接器会通过名称自
动识别 C++ 全局构造函数和析构函数。对于这些目标文件格式，CONSTRUCTORS 命令告诉链接器在
输出分区中保存构造函数信息，保存的位置就是该命令在分区中出现的位置。对于其他目标文件格式，
CONSTRUCTORS 命令会被忽略。

符号 CTOR_LIST 标记全局构造函数的开始，符号 CTOR_END 标记结束。同样，DTOR_LIST 和 DTOR_END
分别标记全局析构函数的开始和结束。列表中的第一个条目的值表示条目的个数，后面是每个构造函
数或析构函数的地址，最后是一个值为零的条目。编译器必须安排实际运行这些代码。对于这些目标
文件格式，GNU C++ 通常会从子程序 __main 中调用构造函数，对 __main 的调用会自动插入 main
的启动代码中。GNU C++ 通常会通过 atexit 或直接从 exit 函数运行析构函数。

对于支持任意名称分区的目标格式，例如 COFF 或 ELF，GNU C++ 通常会安排将全局构造函数和析
构函数的地址放入 .ctors 和 .dtors 分区中。以下脚本会创建 GNU C++ 类似的函数列表： ::

    __CTOR_LIST__ = .;
    LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)
    *(.ctors)
    LONG(0)
    __CTOR_END__ = .;
    __DTOR_LIST__ = .;
    LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2)
    *(.dtors)
    LONG(0)
    __DTOR_END__ = .;

如果使用的 GNU C++ 支持初始化优先级，它可以控制全局构造函数运行顺序，必须在链接时对构造
函数进行排序，保证它们以正确的顺序执行。当使用 CONSTRUCTORS 命令时，使用 ``SORT_BY_NAME(CONSTRUCTORS)``。
当使用 .ctors 和 .dtors 分区时，使用 ``*(SORT_BY_NAME(.ctors))`` 和 ``*(SORT_BY_NAME(.dtors))``。
通常，编译器和链接器会自动处理这些问题，你不需要担心。但是，如果使用 C++ 并且编写自己的
链接脚本，可能需要考虑这一点。

输入分区描述
------------

一个输入分区描述包含一个文件名，后面跟随一个可选的包含在括号里的分区名称列表。文件名和分
区名都可以使用通配符，会在后文介绍。最常用的输入分区描述是将所有同一名称的输入分区包含到
输入分区中，例如： ::

    *(.text)

它将所有输入文件中的 .text 分区包含进来，这里通配符 * 匹配任何文件名。如果需要排除一些
文件，可以使用 EXCLUDE_FILE 来排除指定的非文件。例如： ::

    EXCLUDE_FILE(*crtend.o *otherfile.o) *(.ctors)
    *(EXCLUDE_FILE(*crtend.o *otherfile.o) .ctors)

这两种方式是等价的，都表示除了文件 ``*crtend.o`` 和 ``*otherfile.o`` 之外，包含所有其
他文件中的 .ctors 分区。有两种方法包含文件中的多个分区： ::

    *(.text .rdata)
    *(.text) *(.rdata)

第一种方法是将一个文件中的两个分区放到一起，然后是下一个文件中的这两个分区；第二种方法是
将所有文件中的 .text 分区放到一起，接着是所有文件中的 .rdata 放到一起。当在多个分区中使
用 EXCLUDE_FILE 时，它的两种方式的含义有区别： ::

    EXCLUDE_FILE(*somefile.o) *(.text .rdata)
    *(EXCLUDE_FILE(*somefile.o) .text .rdata)
    *(EXCLUDE_FILE(*somefile.o) .text EXCLUDE_FILE(*somefile.o) .rdata)

第一种方式是除了 ``*somefile.o`` 文件外，包含所有其他文件中的 .text 和 .rdata 分区，
第一种方式可以等价地写成第三行的形式。而第二种方式中会包含所有文件中的 .rdata 分区，但
是只包含除 ``*somefile.o`` 文件外的其他文件中的 .text 分区。可以包含指定文件中的分区，
这种用法通常是这个特定的文件中包含特殊的数据需要放到特定的内存位置。例如： ::

    data.o(.data)

使用 INPUT_SECTION_FLAGS 可以只包含满足分区标记要求的输入分区，例如下面使用分区头部标
记的 ELF 格式分区的例子： ::

    SECTIONS {
        .text : { INPUT_SECTION_FLAGS (SHF_MERGE & SHF_STRINGS) *(.text) }
        .text2 : { INPUT_SECTION_FLAGS (!SHF_WRITE) *(.text) }
    }

这个例子中，输出分区 .text 只包含设置了 SHF_MERGE 和 SHF_STRINGS 这两个分区头部标记的
输入分区。输出分区 .text2 只包含没有设置 SHF_WRITE 分区头部标记的输入分区。

还可以包含归档文件中的分区，其中冒号两边不能有空白字符：

archive:file
    匹配归档文件中的成员文件
archive:
    匹配整个归档文件
:file
    匹配文件，但不是归档中的文件

其中 archive 和 file 都可以包含通配符。在基于 DOS 的文件系统上，链接器会将单个字符和一
个冒号解析为驱动器名称，因此 ``c:myfile.o`` 是一个简单的文件，而不是归档文件 c 中的文
件 myfile.o。这种归档文件形式的文件 archive:file 也可以用在 EXCLUDE_FILE 列表中，但是
归档文件形式不能出现在链接脚本其他上下文中。例如，不能在 INPUT 命令中使用 archive:file
从 archive 中解压 file 文件出来。

如果单单使用一个文件名，不指定分区列表，表示文件中的所有分区都包含到输出分区中。例如： ::

    data.o

当使用一个不是 archive:file 且不包含任何通配符的文件名时，链接器首先会检查这个文件是否
已经在链接器命令行或 INPUT 命令中也指定了。如果没有指定，链接器会尝试将该文件作为输入文
件打开，就像是它出现在命令行上一样。这种方式与 INPUT 命令不同，这里不会在库目录搜索这个
文件。

当使用命令行选项 --gc-sections 打开链接时的垃圾收集时，通常需要标记哪些分区是不能被消除
的。这通过将输入分区描述包含到 KEEP() 中来实现，例如： ::

    KEEP(*(.init))
    KEEP(SORT_BY_NAME(*)(.ctors))

包含通用符号
------------

通用符号需要特殊的表示方法，因为在许多目标文件格式中，通用符号并没有特定的输入分区。链接
器将通用符号视为位于 COMMON 输入分区中。可以像其他任何输入分区一样使用 COMMON，比如将来
自特定输入文件的通用符号放置到一个分区，而来自其他输入文件的通用符号放到另一个分区。在大
多情况下，输入文件中的通用符号会放置到 .bss 输出分区中。例如： ::

    .bss { *(.bss) *(COMMON) }

一些目标文件格式有多种类型的通用符号，例如 MIPS ELF 目标文件格式区分了标准的通用符号和
短小通用符号，链接器使用 COMMON 表示标准统一符号，使用 .scommon 表示短小通用符号。这允
许将不同类型的通用符号映射到内存不同位置。在旧链接脚本中可能看到 ``[COMMON]`` 这种用法，
它是一种过时的用法，等价于 ``*(COMMON)``。

输入分区匹配
-------------

输入分区描述中，文件名和分区名都可以使用通配符进行匹配。可以使用下面这些 Unix shell 匹
配模式：

``*``
    匹配任意数量的字符
``?``
    匹配单个字符
``[chars]``
    匹配字符集合中的一个字符，可以使用横杠字符表示范围，例如 ``[a-z]`` 表示小写字母
``\``
    匹配其后的字符

指定通配符的文件名，只会匹配命令行中以及 INPUT 命令中提供的文件。链接器不会扩展通配符去
查找目录。如果一个文件匹配多个文件匹配模式，或者一个显式指定的文件也与一个文件匹配模式匹
配，链接器会选择链接脚本中的第一个匹配。例如下面的脚本可能是一个错误的脚本，因为第二行中
data.o 对应的规则始终不会被用到： ::

    .data : { *(.data) }
    .data1 : { data.o(.data) }

正常情况下，链接器会按照链接过程中看到的文件顺序，来放置成功匹配的文件分区。但可以使用
SORT_BY_NAME 关键字来改变这一行为，该关键字只用括号包含一个匹配模式，这时链接器会按文件
或分区名称的升序顺序放入到输出分区中，例如 SORT_BY_NAME(.text*)。SORT_BY_ALIGNMENT
与 SORT_BY_NAME 类似，不同的是将分区按对齐字节数的降序顺序排列，将较大对齐字节要求的分
区放置在前面可以减少所需的填充量。SORT_BY_INIT_PRIORITY 也类似于 SORT_BY_NAME，不同
的是根据分区的 GCC 初始化优先级属性的数字升序进行排列。例如 .init_array.NNNNN 分区和
.fini_array.NNNNN 中，NNNNN 表示初始化优先级。在 .ctors.NNNNN 和 .dtors.NNNNN 分区
中，NNNNN 是 65535 减去初始化优先级。另外，SORT 是 SORT_BY_NAME 的别名。REVERSE 表示
反向的排列顺序，如果单独使用表示 SORT_BY_NAME 反序，否则表示对应的顺序反序，但是不能对
SORT_BY_ALIGNMENT 进行反序。另外 REVERSE 只接受单个匹配模式，例如下面第一行脚本是不正
确的，必须使用单独的匹配： ::

    *(REVERSE(.text* .init*))
    *(REVERSE(.text*)) /* 必须只包含单个模式 */
    *(REVERSE(.init*))

可以将 EXCLUDE_FILE 命令放到排序命令的内部，不能放在之外。例如下面第一行脚本是正确的，
第二行不行： ::

    *(SORT_BY_NAME(EXCLUDE_FILE(foo) .text*))
    *(EXCLUDE_FILE(foo) SORT_BY_NAME(.text*))

如果有嵌套的排序命令，最多只能嵌套一个：

1. SORT_BY_NAME(SORT_BY_ALIGNMENT(section_pattern)) 先按名称排序，再将同名分区按对
   齐排序
2. SORT_BY_ALIGNMENT(SORT_BY_NAME(section_pattern)) 先按对齐排序，再将相同对齐的分
   区按名称排序
3. SORT_BY_NAME(SORT_BY_NAME(section_pattern)) 与 SORT_BY_NAME(section_pattern)
   相同
4. SORT_BY_ALIGNMENT(SORT_BY_ALIGNMENT(section_pattern)) 与 SORT_BY_ALIGNMENT(section_pattern)
   相同
5. SORT_BY_NAME(REVERSE(section_pattern)) 名称逆序
6. REVERSE(SORT_BY_NAME(section_pattern)) 名称逆序
7. SORT_BY_INIT_PRIORITY(REVERSE(section_pattern)) 先按优先级排序，再逆序
8. 所有其他嵌套形式都不合法

如果同时指定了命令行分区排序选项以及链接脚本分区排序命令，脚本中的排序命令优先于命令行选
项。如果脚本中的分区排序命令没有嵌套，命令行选项可能使得脚本命令变成嵌套的命令：

1. SORT_BY_NAME(section_pattern) 搭配 --sort-section alignment 等价于先按名称排序，
   再按对齐排序，SORT_BY_NAME(SORT_BY_ALIGNMENT(section_pattern))
2. SORT_BY_ALIGNMENT(section_pattern) 搭配 --sort-section name 等价于先按对齐排序，
   再按名称排序，SORT_BY_ALIGNMENT(SORT_BY_NAME(section_pattern))

如果脚本中的命令已经是嵌套的，命令行指定的分区排序选项会被忽略。而使用 SORT_NONE 通过忽
略命令行的分区排序选项来关闭输入分区的排序。如果有所混淆，可以使用 -M 选项生成对应的映射
文件，其中会精确的反映出输入分区是怎样映射到输出分区的。

下面是一个输入分区匹配的例子，链接器会将所有 .text 输入分区放入 .text 输出分区中，所有
.bss 输入分区放入 .bss 输出分区中。并且，以大写字面开头的文件中的 .data 输入分区会放入
到 .DATA 输出分区，其他文件中的 .data 输入分区放入 .data 输出分区。 ::

    SECTIONS {
        .text : { *(.text) }
        .DATA : { [A-Z]*(.data) }
        .data : { *(.data) }
        .bss : { *(.bss) }
    }

下面的例子是一个完整的链接脚本。它告诉链接器读取文件 all.o 中的所有分区放到 outputa 分
区的开头，输出分区 outputa 的起始地址是 0x10000。接着是文件 foo.o 中的所有 .input1 分
区放到同一个输出分区中。文件 foo.o 中的所有 .input2 分区以及 foo1.o 中的所有 .input1
分区放到输入分区 outputb。最后，所有文件中剩下的 .input1 分区和 .input2 分区都放到输出
分区 outputc 中。 ::

    SECTIONS {
        outputa 0x10000 :
        {
            all.o
            foo.o (.input1)
        }
        outputb :
        {
            foo.o (.input2)
            foo1.o (.input1)
        }
        outputc :
        {
            *(.input1)
            *(.input2)
        }
    }

如果一个输出分区名称与输入分区的名称相同，并且可以表示为一个 C 语言标识符，那么链接器会
自动提供两个符号：__start_SECNAME 和 __stop_SECNAME，其中 SECNAME 是分区的名称。这两
个符号分别对应输出分区的起始地址和结束地址。注意，大多数分区名称都不能表示为 C 标识符，
因为它们包含一个点字符。
