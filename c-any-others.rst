其他内容
=========

* `链接插件`_
* `特殊分区`_
* `MRI 脚本`_
* `BFD 库`_
* `ARM 平台`_
* `WIN32 系统`_

链接插件
--------

链接器可以使用动态加载的插件来修改链接器行为，例如一些编译器支持的链接时优化是通过链接插
件实现的。目前，默认情况下只附带了一个插件，但以后可能会添加更多插件。通过使用命令行选项
``-plugin name`` 启用插件。

**静态库依赖插件**

最初静态库被包含在一个仅由一些列重定位目标文件组成的归档文件中，后来它们发展成可以包含一
个可选的符号表，以帮助在库中找到所需的目标。这样动态链接库开始占据主导地位。

动态库的一个有用特性是，不仅仅可以将多个目标收集到一个单一文件中，而且还包含了它们的依赖
列表，这样只需在链接时指定单个动态库的名称，其所有依赖项也会被隐式引用。但静态库缺乏这一
特性，因此如果将一个链接调用从使用动态库切换到使用静态库，除非重写链接命令以显式地列出静
态库的依赖关系，否则链接命令通常会失败。

GNU ar 现在支持一个 --record-libdeps 选项，用于将依赖列表嵌入到静态库中，并且可以使用
libdep 插件在链接时读取此依赖信息。依赖信息存储为一个单独的字符串，携带着它们通常会出现
在链接器命令行中的 -l 和 -L 参数。因此，这些信息可以用任何文本工具编写，并存储到任何归档
文件中，即使不是使用 GNU ar 来创建归档文件。这些信息存在在一个名为 __.LIBDEP 的归档成
员中。

例如，假设一个库 libssl.a 依赖另一个可能位于 /usr/local/lib 的库 libcrypto.a，那么库
libssl.a 的 __.LIBDEP 成员文件将包含： ::

    -L/usr/local/lib -lcrypto

注意，以这种方式添加的任何库搜索目录仅用于搜索统一插件添加的库。它们不用于搜索链接器命令
行、链接器脚本或其他插件中指定的库。然后，如果存在多个带有 __.LIBDEP 成员的归档文件，这
将带来一个问题，因为它们都由 libdep 插件处理，因此它们会共享库搜索路径，这可能导致从一个
不预期的位置加载到一个库。

**LTO 插件**

尽管没有附带再 binutils 中，但来自 GCC 项目的链接时优化（LTO, Link Time Optimization）
插件是一个设计用来与链接器一起工作的插件。该插件拦截链接器加载的对象文件，并将它们发送给
LTO 编译器。当编译器完成后，生成的目标文件会传回给链接器进行常规处理。

特殊分区
--------

当链接 ELF 格式目标文件时，链接器会以一种特殊的非标准的方式处理一些分区。这些分区包括：

.gnu.warning
    具有此名称的任何分区的内容都假定为 ASCII 格式的警告信息。如果输入文件中出现这些分区，
    内容将显式给用户，但分区不会被复制到输出映像中。如果启用了 --fatal-warnings 选项，
    那么如果遇到警告，会结束链接器的执行。注意 .gnu.warning 分区不受链接器垃圾收集以及
    孤立分区处理的影响。
.gnu.warning.SYM
    名称以 .gnu.warning. 为前缀并以符号名称结束的任何分区，将被类似地处理为 .gnu.warning
    分区，但只有在命名符号被引用时才处理。例如，如果符号 foo 被一个或多个输入文件引用，
    名为 .gnu.warning.foo 的分区内容才被当作警告信息使用。这包括从静态库中提取的目标文
    件、完成链接解析所需的共享目标文件等等。由于这些警告信息是在链接器执行垃圾收集（如果
    启用）之前生成，因此相对于一个符号的警告信息，可能后来被移除了导致不会出现在最终的输
    出中。
.note.gnu.property
    当链接器合并该名称的分区时，会根据编码在说明分区中的各种规则进行合并。因此，输出分区
    .note.gnu.property 的内容可能不会简单地与输入分区的合并内容对应。如果使用了命令行
    选项 -Map 则链接器会生成一个映射文件，其中包含了输入分区到输出分区的详细映射信息。

MRI 脚本
---------

GNU 链接器可以帮助用户从 MRI 链接器过渡到 GNU 链接器，因为 GNU 链接器可以使用 MRI 兼容
的链接脚本，作为更通用的链接脚本语言的替代。MRI 兼容的脚本使用的命令集比GNU 链接器通用
脚本简单得多，这些命令将在下面描述。

通常，MRI 脚本在 a.out 目标文件格式上没有太大用处，因为它只有三个分区，而 MRI 脚本缺少
利用这些分区的特性。可以使用 -c 命令行选项指定一个包含 MRI 兼容脚本的文件。MRI 兼容脚本
中的每个命令都占据自己的一行，每个命令行都以标识命令关键字开始（尽管也允许使用空行作为标
点）。如果 MRI 兼容脚本的一行以无法识别的关键字开始，链接器会报警告错误，但会继续处理脚
本。以星号（*）开头的行是注释。可以使用全部大写字母或全部小写字母来书写这些命令，例如命
令 chip 与 CHIP 相同，以下是大写形式的命令列表：

ABSOLUTE secname ABSOLUTE secname, secname, ... secname
    通常情况下，链接器会在输出文件中包含输入文件中的所有分区。然而在 MRI 兼容脚本中，可
    以使用 ABSOLUTE 命令来限制出现在输出文件中的分区。如果脚本中使用了 ABSOLUTE 命令，
    则只有其中明确指定的分区才会出现在输出文件中。但仍然可以使用其他输入分区（不管是是在
    命令行设定的还是使用 LOAD 命令选择的）来解析输出文件中的地址。
ALIAS out-secname, in-secname
    使用这个命令将输入分区放置到对应的输出分区中，其中 in-secname 可能是一个整数。
ALIGN secname = expression
    将分区对齐到表达式对应的值，这个值必须是2的幂。
BASE expression
    使用表达式的值作为输出文件中的最低地址（除了绝对地址保持不变）
CHIP expression CHIP expression, expression
    该命令不做任何事，仅为兼容
END
    该命令不做任何事，仅为兼容
FORMAT output-format
    类似于通用链接语言中的 OUTPUT_FORMAT 命令用来指定输出目标文件格式。但如果输出格式
    是 S，则仅限于 S-records。
LIST anything...
    将链接映射输出到标准输出文件，就行链接器命令行选项 -M 产生的那样。LIST 关键字后面可
    以同一行跟随任意内容。
LOAD filename LOAD filename, filename, ... filename
    包含一个或多个目标文件到链接器中，跟直接在命令行指定输入文件类似。
NAME output-name
    指定链接器输出文件的名称，等价于命令行选项 -o 或者通用脚本语言中的 OUTPUT 命令。
ORDER secname, secname, ... secname ORDER secname secname secname
    通常，链接器按照输入文件中分区的出现顺序放置到输出文件中。在 MRI 兼容脚本中，可以使
    用 ORDER 命令来覆盖这种排序，使用 ORDER 列出的分区将首先出现在输出文件中，按照指定
    的顺序排列。
PUBLIC name=expression PUBLIC name,expression PUBLIC name expression
    给链接器输入文件中的外部符号指定一个表达式表示的值。
SECT secname, expression SECT secname=expression SECT secname expression
    可以使用 SECT 命令指定分区的起始地址，如果有针对同一个分区的 SECT 命令，只有第一个
    会生效。

BFD 库
-------

链接器使用 BFD（Binary File Descriptor）库来访问目标文件和归档文件。这些库允许链接器
使用相同的过程来操作目标文件，不管目标文件的格式是什么。只需要创建一个新的 BFD 后端并将
器添加到库中，就可以简单地支持不同的目标文件格式。然而，为了节省运行内存，链接器和相关工
具通常被配置为只支持可用目标文件格式的一个子集。可以使用 objdump -i 查看当前平台的配置
支持的所有格式。

与大多数实现一样，BFD 是在几个相互冲突的要求之间的折衷。影响 BFD 设计的主要因素是效率，
任何用于格式转换的时间都是本可以在不涉及 BFD 的情况下可节省的。这部分被抽象带来的好处所
抵消，因为 BFD 简化了应用程序和后端程序，更多的关注是对算法进行优化来获得更好的速度。

BFD 解决方案的另一个注意点是，在进行不同目标格式的信息转换时，或将标准的内部表示输出到
特定的目标格式时，可能存在信息丢失。

**a.out 格式**

BFD 支持多种不同风格的 a.out 格式，尽管主要的区别只是磁盘上结构的大小和重定位信息的组织
方式。该格式的支持被分为一个基本支持文件 aoutx.h 和从基础派生功能的其他文件。一个派生文
件是 aoutf1.h（用于 a.out 风格 1），它为 sun3、sun4、以及 386 a.out 文件增加了对基本
a.out 函数的支持，以创建特定目标的跳转向量。

这些信息进一步被细分为针对每种机器的更特定的文件，包括 sunos.c（针对 sun3 和 sun4），
以及 demo64.c（用于演示64位 a.out 格式）。基础文件 aoutx.h 定义了读写记录到磁盘的通用
机制以及 BFD 所需的各种其他方法。它被 aout32.c 和 aout64.c 包含以形成相对应的名字，例
如 aout_32_swap_exec_header_in、aout_64_swap_exec_header_in。

**coff 格式**

BFD 支持多种不同风格的 COFF 格式，格式之间的主要区别是磁盘上结构中的字段的大小和对齐、
以及额外的字段定义。COFF 格式的所有变体，使用通用文件和多个特定文件来实现。例如，i386
COFF 格式实现在 coff-i386.c 文件中。而文件 coff/i386.h 定义了 i386 的 COFF 格式的外
部结构，文件 coff/internal.h 定义了内部使用的结构。coff-i386 还定义了 i386 COFF 格式
使用的重定位。

**elf 格式**

目前，sparc 和 i386 的 ELF 后端格式得到了最好的支持。

**mmo 格式**

目标文件格式 mmo 是与 Donald E. Knuth 教授的教育性64位处理器 MMIX 一起专用的。可在网
站 http://mmix.cs.hm.edu/src/index.html 获取 mmix 模拟器理解此格式。该软件还包含一个
集成的汇编器和链接器，称为 mmixal。与其他格式例如 ELF 相比，mmo 格式在功能上没有任何优
势。它是一个简单的不可重定位的目标格式，不支持存档，也不支持除了符号值信息和行号外的调试
信息。有关 MMIX 的更多信息，可访问 http://mmix.cs.hm.edu/。在 BFD 实现中，使用 ELF
格式作为中间目标文件。

ARM 平台
---------

在 ARM 架构平台上，链接器会生成占位代码以便在 ARM 和 Thumb 代码之间的函数调用。这些占
位仅在打开了 -mthumb-interwork 选项进行编译和汇编的代码中有效。如果需要与旧的 ARM 目标
文件或库进行链接，而这些文件或库没有使用 --mthumb-interwork 选项来编译，那么应该向链接
器提供 --support-old-code 选项。这回产生更大的占位函数，让不能 interwork 的 ARM 代码
正常工作。但链接器不支持为不能 interwork 的 Thumb 代码生成函数调用的占位代码。

命令行选项 --thumb-entry 与 --entry 选项类似，提供程序的起始地址。但是它还设置了地址的
最低位，以便可以使用 BX 指令跳转到它的位置，然后程序就会立即进入 Thumb 模式开始执行。选
项 --use-nul-prefixed-import-tables 指定，必须为导入库生成有零元素前缀的导入表 idata4
和 idata5。这时生成导入表的旧方式，默认情况下该选项是关闭的。选项 --be8 指定链接器生成
BE8 格式的可执行文件。此选项仅在链接大端目标时有效，即那些使用了 -EB 选项进行汇编的目标。
这样生成的映像将包含大端数据和小端代码。

R_ARM_TARGET1 重定位通常用于 .init_array 分区中的条目。根据目标，它被解析为 R_ARM_REL32
或者 R_ARM_ABS32。使用 --target1-rel 和 --target1-abs 选项可以覆盖默认设置。命令行选
项 --target2-type 会覆盖 R_ARM_TARGET2 重定位的默认定义，合法的 type 值如下： ::

    rel         R_ARM_REL32 (arm*-*-elf, arm*-*-eabi)
    abs         R_ARM_ABS32
    got-rel     R_ARM_GOT_PREL (arm*-*-linux, arm*-*-*bsd)

R_ARM_V4BX 重定位（由 ARM AAELF 规范定义）使得 ARMv4 架构编译的目标可以安全的 interwork，
当与 ARMv4t 架构的目标进行链接时。同时也允许从相同的 ARMv4 目标构建除纯净的 ARMv4 二进
制文件。在有一种情况下，必须向链接器传递 --fix-v4bx 选项，这使得 v4t BX rM 指令改写成
MOV PC,rM，因为 v4 处理器没有 BX 指令。在前一种情况下，不应使用该选项，R_ARM_V4BX 重
定位会被忽略。由 R_ARM_V4BX 重定位标识的 BX rM 指令通过一个分支替换为以下代码： ::

    TST rM, #1
    MOVEQ PC, rM
    BX Rn

这允许生成的库和程序可以工作在 ARMv4 核心上，并且仍然是 interwork 安全的。但注意上面的
代码会破坏条件标记，因此在极少数情况下可能会导致程序行为不正确。选项 --use-blx 使链接器
能够在各种情况下使用 ARM/Thumb BLX 指令（在 ARMv5t 及以上版本可用）。它会根据 Thumb
代码中的 PLT 使用 BLX 进行函数调用，而不是使用 BX 指令在每个 PLT 条目之前都进行一次模
式切换。这可以提高这些调用的执行速度。

选项 --vfp11-denorm-fix 针对某些 VFP11 协处理器硬件故障启用链接时规避方法，这有时允许
具有非正规操作数的命令（必须由支持的代码处理）将这些操作数在支持的代码读取预期值之前替换
成后续的指令。在标量模式下（scalar mode）如果在使用一个寄存器的 VFP11 指令和另一个写入
同一个寄存器的指令之间允许存在至少一个中间指令，或者在矢量模式下（vector mode）至少允许
两个中间指令，那么这种故障可以避免。这种故障仅影响完全兼容的浮点模式，如果使用 runfast
模式，则不需要这种规避方法。查看 ARM 规范文档获取更大详细信息。

如果你知道你正在使用有缺陷的 VFP11 硬件，可以通过指定链接器选项 --vfp-denorm-fix=scalar
（如果仅使用 VFP11 标量模式）、或者 --vfp-denorm-fix=vector（该模式也适用于标量代码）
来启用此规避方法。它的默认值为 --vfp-denorm-fix=none。如果启用了规避方法，会扫描指令以
查找可能有问题的序列，并为可能除非故障的每个序列创建一块上面介绍的替换代码。这个替换代码
有序列的第一个指令和一个跳回到后续指令的分支组成。然后，原始指令被替换为跳转到替换指令的
分支。调用替换代码到代码返回所需的额外周期需要足够用来解决标量和矢量模式下的故障。

选项 --fix-arm1176 启用针对某些 arm1176 处理器故障的链接时规避方法。如果针对 ARMv6（不
包括 ARMv6T2）或更早版本，该规避方法默认情况下不会被启用。还可以通过指定 --no-fix-arm1176
禁用该规避方法。更多的信息参考在 ARM 文档网站（http://infocenter.arm.com/）上的程序员
建议文档（ARM1176JZ-S and ARM1176JZF-S Programmer Advice Notice）。

选项 --fix-stm3214xx-629360 启用真多某些 STM32 Cortex-M4 的产品（STM32L4xx）的总线
矩阵/内存控制器故障的链接时规避方法。当通过受影响的总线访问片外存储器时，如果总线读取超
过 9 个字长或更多，总线可能会生成损坏的数据异常终止。这些只是核心发起的访问（不是 DMA），
并且可能会影响任何访问，例如整数加载的 LDM、POP、和浮点加载的 VLDM、VPOP。存储操作不受
影响。可以通过将内存访问分割成必要的块了避免错误，以保持总线读取不超过8个字长。默认情况
下，不会启用此规避方法，这等同于使用 --fix-stm3214xx-629360=none。如果你知道你正在使
用有缺陷的 STM32L4xx 硬件，可以通过指定 --fix-stm3214xx-629360=default 或等价的选项
--fix-stm3214xx-629360 来启用规避方法。如果启用了规避方法，将扫描指令以查找可能有问题
的序列，并未可能触发错误的每个序列创建一块替换代码。当指令加载 PC 时，规避方法并不总是保
留 LDMDB 指令的内存访问顺序。当它们位于 IT 块中间时，规避方法无法处理有问题的指令，因为
那里不允许分支跳转。在这种情况下，当替换原始代码无法编码时，链接器就会报错，并且不会发生
替换。如果 .text 分区太大，规避方法无法使用 PC 相对分区指令替换有问题的指令。这种情况下，
链接器也会报错，并且不会发生替换。

选项 --no-enum-size-warning 防止链接器在链接指定了不兼容的 EABI 枚举大小属性的目标文件
时发出警告。例如将一个使用32为枚举值的目标文件，与另一个使用尽可能最小枚举值的目标文件进
行链接时，不会产生警告。选项 --no-wchar-size-warning 防止链接器在连接指定了不兼容的 EABI
wchar_t 大小属性的目标文件时发出警告。例如将使用了32位 wchar_t 值的目标文件与另一个使用
了16位 wchar_t 值得目标文件进行链接，不会产生警告。

尽管二进制文件得其余部分不是 PIC，选项 --pic-veneer 会让链接器为 ARM/Thumb 互操作的占
位代码使用 PIC 序列。这样可以避免在 uClinux 平台使用 --emit-relocs 生成可重定位二进制
文件时的问题。

链接器在尝试对很远的符号执行函数调用时，会自动生成并插入一小段代码序列到链接的 ARM ELF
可执行文件中。这些占位的指令序列的安置由命令行选项 --stub-group-size=N 控制。安置很重
要，因为错误的设置可能会导致重复的占位代码，增加代码大小。链接器会按顺序将占位代码放到一
组以减少代码流的打断，但这需要一个指导数据用来决定这些分组的大小以及放置的位置。其中参数
N 控制放置位置，如果时负数则所有替换代码放置在第一个需要它们的分支指令之后。如果时正数，
则可以放置在它们的分支指令之前或者之后。如果 N 的值为 1（不管是-1还是+1），链接器将使用
其内置启发式方法精确选择放置一组占位代码的位置。当 N 大于 1 或者小于 -1，表示一组占位代
码最多服务输入分区中的 N 个字节。如果没有指定 --stub-group-size=N，相当于 N 的默认值，
其值为正 1。远调用插入占位代码仅在 ARM-EABI 目标平台上完全支持，因为这依赖于其他目标平
台不存在的目标文件属性。

选项 --fix-cortex-a8 启用了针对某些 Cortex-A8 处理器故障的链接时规避方法。如果针对的是
ARM v7-A 架构配置文件，默认情况下会启用该规避方法。可以通过 --fix-cortex-a8 启用，或者
使用 --no-fix-cortex-a8 禁用。这个故障只影响 Thumb-2 代码，详细情况参考 ARM 规范文档。

选项 --fix-cortex-a53-835769 启用了针对 Cortex-A53 处理器某些早期版本中出现的 835769
故障的链接时规避方法。默认情况下，此规避方法是禁用的。可以使用 --fix-cortex-a53-835769
启用，或者使用 --no-fix-cortex-a53-835769 禁用。详细情况参考 ARM 规范文档。

选项 --no-merge-exidx-entries 禁用在 debuginfo 中合并相邻的 exidx 条目。--long-plt
选项启用使用16字节的 PLT 条目，这些条目支持高达 4Bb 大小的代码。默认情况下，使用12字节
的 PLT 条目，仅支持 512Mb 大小的代码。--no-apply-dynamic-relocs 使 AArch64 链接器在
链接时不应用动态重定位的值。

所有 SG 占位代码都放置在特殊的输出分区 .gnu.sgstubs 中。必须设置该分区的起始地址，要么
使用命令行选项 --section-start，要么可以在链接器脚本中设置。

选项 --cmse-implib 要求由 --out-implib 和 --in-implib 选项指定的导入库是安全网关导入
库，适用于根据 ARMv8-M 安全扩展将非安全可执行文件和安全代码进行链接。--in-implib=file
选项指定了一个输入导入库，并且其中的符号必须在正在生成的可执行文件中保持相同的地址。如果
没有指定的 --out-implib 选项，但可执行文件中引入了应该在其导入库中列出的新符号，链接器
会产生警告。否则，如果制定了 --out-implib，则会将符号添加到输出导入库中。如果输入导入库
中的一些符号在可执行文件中不存在，也会产生警告。这个选项进队安全网关导入库有效，即当指定
了 --cmse-implib 选项时。

WIN32 系统
-----------

这里描述 cygwin/mingw 等 WIN32 系统上的 GNU 链接器相关内容。

**导入库**

标准 Windows 链接器会创建导入库（import libraries），这种库包含链接 dll 库的信息。它
们是常规的静态归档文件并且像其他静态库一样处理。cygwin 和 mingw 版本的链接器提供了命令
行选项 --out-implib 来特别支持创建这种库。

**资源型 DLL**

可以创建一个仅包含资源的 DLL，即只有一个 .rsrc 分区，这需要使用定制的链接脚本才能做到。
这时因为内置的默认链接脚本总是会创建 .text 以及 .idata 分区，尽管这些分区不包含内容。以
下是一个脚本示例，其中 OUTPUT_FORMAT 按需要改成你想要的目标格式。 ::

    OUTPUT_FORMAT(pei-i386)
    SECTIONS
    {
        . = SIZEOF_HEADERS;
        . = ALIGN(__section_alignment__);
        .rsrc __image_base__ + __section_alignment__ : ALIGN(4)
        {
            KEEP (*(.rsrc))
            KEEP (*(.rsrc$*))
        }
        /DISCARD/ : { *(*) }
    }

该脚本保存为 rsrc.ld，下面的命令用来创建一个 rsrc.dll 动态链接库文件： ::

    ld -dll --subsystem windows -e 0 -s rsrc.o -o rsrc.dll -T rsrc.ld


**导出 DLL 符号**

cygwin/mingw 版本的链接器有几种导出符号到 DLL 的方法：使用自动导出功能，使用 def 文件，
在源代码中的使用 __declspec 声明。

默认情况下，链接器会通过自动导出功能导出符号，它们通过以下命令行选项控制： ::

    --export-all-symbols # 默认选项
    --exclude-symbols
    --exclude-libs
    --exclude-modules-for-implib
    --version-script

当自动导出功能开启时，链接器在生成 DLL 文件时会自动导出其中找到的所有非本地符号，包括全
局（global）和通用（common）符号。除了少部分是已知属于系统运行时或库符号不会被导出。由
于通常不希望导出所有符号，其中可能包括不是任何公共结构一部分的私有函数，所有可以使用上面
的命令行选项排除不需要的符号。使用 --output-def 选项可以看到最终的导出符号列表，同时考
虑了所有排除项。如果命令行没有明确给出 --export-all-symbols，那么自动导出功能在以下情
况下会被禁用：

1. 使用了一个 DEF 文件
2. 任何目标文件中的符号使用了 __declspec(dllexport) 属性修饰符

如果使用了一个 DEF 文件，会根据该文件导出符号。DEF 文件是一个 ASCII 文件包含当创建 DLL
文件时需要导出的符号。通常该文件被命名为 <dll name>.def，后缀名必须时 .def 或者 .DEF，
DEF 文件向其他命令行输入文件一样传入，例如： ::

    gcc -o <output> <objectfiles> <dll name>.def

使用 DEF 文件会禁掉自动导出功能，除非显式指定了 --export-all-symbols 选项。以下是一个
共享库 xyz.dll 对应的 DEF 文件： ::

    LIBRARY "xyz.dll" BASE=0x20000000

    EXPORTS
    foo
    bar
    _bar = bar
    another_foo = abc.dll.afoo
    var1 DATA
    doo = foo == foo2
    eoo DATA == var1

该文件定义了一个 DLL，具有非默认基地址以及导出表中的七个符号。第三个导出符号 _bar 是第
二个符号的别名。第四个符号 another_foo 通过转发创建另一个库（abc.dll）中的符号（afoo）
的别名。最后一个符号 var1 被声明为数据对象。导出库中的 doo 符号是 foo 的别名，并在导出
表中获得了一个名称 foo2。符号 eoo 是一个数据导出符号，并在导出表中获得了一个名称 var1。

可选的命令 LIBRARY <name> 指定输出 DLL 文件的内部名称，如果没有指定后缀名，将附加默认
后缀名 .DLL。当使用 DEL 文件构建应用程序而不是动态库时，应该使用 NAME 而不是 LIBRARY
命令，如果不包含后缀，则附加默认可执行文件后缀 .EXE。无论是库还是可执行文件，都可以使用
BASE 为映像指定非默认的基地址。如果未指定 NAME 或 LIBRARY，或者制定了一个空字符串，那
么内部名称与命令行指定的文件名相同。

一个导出符号的完整规范描述如下： ::

    EXPORTS
    ( ((<name1> [= <name2>]) | (<name1> = <module-name>.<external-name>))
      [@ <integer>] [NONAME] [DATA] [CONSTANT] [PRIVATE] [== <name3>] ) *

其中 name1 是 DLL 中的一个导出符号，或者是 name2 的一个导出别名，或者是另一个 DLL 中符
号的别名。可选地，符号可以导出为一个指定序号 <integer> 的别名。可选的 name3 可以在符号
的导入/导出表中作为字符串使用。而其中可选的关键字 NONAME、DATA、CONSTANT、PRIVATE 的含
义如下。

NONAME 表示不要在 DLL 文件中的导出表中保存该符号名称，它仍然可以通过其序号别名（由 DEF
指定或由链接器分配）导出。但是符号名称仍然在导入库中可见，除非还指定了 PRIVATE。

DATA 表示符号是一个变量或者对象，而不是函数。生成的导入库其中导出的符号是对变量例如 foo
的间接引用，即一个名为 _imp__foo 的符号，因此 foo 必须被解析为 ``*_imp_foo``。

CONSTANT 类似于 DATA，但在导入库中放入 _imp__foo 符号的同时，还放入了未修饰的 foo。两
者都引用的是只读导入地址表中的变量的地址，而不是变量本身。这可能是危险的，如果用户代码没
有添加 dllimport 属性，也没有显式添加使用属性所保证的额外间接性信息，应用程序将出现意外
行为。

PRIVATE 将符号放入 DLL 导出表中，但不会放入在链接时用于解析导入符号的静态导入库中。但是
符号仍然可以在运行时使用 LoadLibrary/GetProcAddress 进行导入，或者通过 GNU 链接器扩展
直接链接该 DLL 而不需要对应的导入库。参考 ld/deffilep.y 中的 DEF 文件完整规范。当链接
创建一个 DLL 动态库时，可以使用命令行选项 --output-def 同时创建一个 DEF 文件。

另一种导出动态库符号的方法是修改源代码本身，每个要导出的符号都声明为： ::

    __declspec(dllexport) int a_variable;
    __declspec(dllexport) void a_function(int with_args);

如果任何目标文件中包含这种修饰的符号时，会禁用正常的自动导出功能，除非同时指定了命令行选
项 --export-all-symbols。但是当使用动态库文件中的符号时，需要使用 dllimport： ::

    __declspec(dllimport) int a_variable;
    __declspec(dllimport) void a_function(int with_args);

这会导致库头文件结构变动复杂，因为要根据情况声明未 dllexport 还是 dllimport。有一些通
用方法可以规避这一点，例如代码完全省略 __declspec 声明，参考 --enable-auto-import 自
动导入选项以及自动数据导入功能。

**自动数据导入**

标准 Windows DLL 格式仅通过在代码中添加 __declspec 声明来支持数据导入，这会让编译器生
成特定的汇编语言指令来处理这种数据导入。这增加了将现有 Unix 代码移植到这些平台所需的工作
量，特别是对于大型 C++ 库和应用程序。自动导入特性最初是由 Paul Sokolovsky 提供，它允许
省略 __declspec 修饰符以实现符合 POSIX/Unix 平台的行为。此特性通过 --enable-auto-import
选项启用，在 cygwin/mingw 上该选项默认会自动启用。因此该选项本身现在主要用于抑制产生的
任何警告，这些警告通常会在链接的目标文件触发了该特性的使用时产生。

变量的自动导入并不总能在没有额外帮助的情况下了完成工作，有时你会看到这样的消息：无法自动
导入变量 <var>，请阅读链接器文档中的 --enable-auto-import 选项以获取详细信息。该选项文
档解释了为什么会出现此错误，并提供了几种可以解决的方法。其中一种方法是下面描述的运行时伪
重定位功能（runtime pseudo-relocs）。

对于从 DLL 导入的复杂变量（如结构体或类），目标文件通过包含变量的基地址和变量内的偏移量
（即附加值 addend），例如指定了特定字段或公共成员。不幸的是，WIN32 环境中使用的运行时加
载器无法在没有 dllimport/dllexport 声明提供的额外信息的帮助下在运行时修复这些引用。也
因此上面标准的自动导入功能不能解析这些引用（即对象内部字段的引用）。

使用选项 --enable-runtime-pseudo-relocs 允许在不出错的情况下解析这些引用，同时将调整
引用本身（及其非零附加值）的任务留给运行时环境提供的专用代码。最新的 cygwin/mingw 环境
和编译器提供了这种运行时支持，但旧版本则没有。然而这种支持仅在开发人员平台上时必需的，因
为编译结果可以在旧系统上无误地运行。--enable-runtime-pseudo-relocs 不是默认选项，必须
显式地指定。

**直接链接 DLL**

cygwin/mingw 版本的链接器支持从 DLL 库文件直接进行链接导入其中的符号（包括数据符号），
而不必借助导入库。这比传统的导入库的方式快很多，也节省了大量内存，特别是当链接大型库或应
用程序时。当链接器创建一个导入库时，DLL 中导出的每个函数或变量都存储在自己这个符号对应的
BFD 中，即使一个 BFD 可以包含很多导出符号。因此存储、加载和处理如果多的 bfd 会产生相当
大的开销，这解释了在使用导入库时尤其是对于特别大或复杂的库，需要大量的时间、内存、和存储
空间。

直接链接 DLL 动态库文件不需要任何额外的命令行选项，除了 -L 和 -l，因为链接器已经搜索到
了匹配每个库的一些列名称。从开发者的角度来看，只需要理解这个搜索过程，就可以知道链接器怎
样直接对 DLL 动态库文件进行链接，而不是从导入库中加载符号。例如，当链接器处理库文件选项
-lxxx 选项时，它会依次按顺序尝试以下的搜索目录，找到第一个找到的库即可： ::

    libxxx.dll.a
    xxx.dll.a
    libxxx.a
    xxx.lib
    libxxx.lib
    cygxxx.dll(*)
    libxxx.dll
    xxx.dll

其中的 cygxxx.dll 不一定是 cygxxx.dll，而实际上是 <prefix>xxx.dll，<prefix> 是由选
项 --dll-search-prefix=<prefix> 指定的名称前缀。在 cygwin 的情况下，标准的 gcc 规范
文件包含 --dll-search-prefix=cyg。其他基于 WIN32 的 Unix 环境，如 mingw 或 pw32，可
能使用其他的 <prefix>，尽管目前只有 cygwin 使用此功能。它最初旨在帮助避免伪各种 WIN32
或 Unix 环境构建的 DLL 之间的名称冲突，以便两个版本的 DLL 可以在同一台机器上共存。

通用的 cygwin/mingw 搜索路径使用 bin 目录查找可执行文件和 DLL 文件，使用 lib 目录查找
导入库文件（使用 cygwin 的命名法）： ::

    bin/
        cygxxx.dll
    lib/
        libxxx.dll.a # 对于 dll 的情况
        libxxx.a     # 对于静态库的情况

直接链接到 DLL 动态库文件，而不是间接的使用导入库，可以通过两种方法完成；

1. 直接使用 DLL，通过将 bin 路径添加到链接命令行中，例如： ::

        gcc -Wl,-verbose -o a.exe -L../bin/ -lxxx

   由于 DLL 的名称通常会附加版本号（例如 cygncurses-5.dll），这常常会失败，除非指定选
   项 -L../bin -lncurses-5 来包含版本号。导入库则通常没有版本，因而没有这个困难。

2. 根据以上的搜索规则，从 DLL 创建一个符号链接保存到 lib 目录中，这样旧不需要改变任何构
   建环境的情况下进行链接： ::

        ln -s bin/cygxxx.dll lib/[cyg|lib|]xxx.dll[.a]
        gcc -Wl,-verbose -o a.exe -L../lib/ -lxxx

   这种方法也规避了版本号的问题，因为下面的做法是完全合法的： ::

        bin/
            cgxxx-5.dll
        lib/
            libxxx.dll.a -> ../bin/cygxxx-5.dll

即使还在使用自动导入功能以及 --enable-runtime-pseudo-relocs，不使用导入库而直接对 DLL
进行链接也是可行的。鉴于链接速度和内存使用方面的改进，人们可能会合理地想知道为什么还要使
用导入库。其中由三个原因：

1. 直到最近，直接链接 DLL 还不支持自动数据导入的功能
2. 有时需要在导入库中包含纯静态的目标（导入库它本来只包含 bfd 间接地指向 DLL 中导出的符
   号），而 cygwin 内核的导入库利用了这个功能，没有导入库是无法做到这一点的
3. 符号别名只能使用导入库来解析，当链接到操作系统提供的 DLL 时，这是至关重要的，其中符号
   通常作为修饰的别名导出，而实际对应的是 stdcall 修饰的汇编名称

所以导入库不会消失。但是，能够简单直接链接到一个 DLL 动态库在很多情况下，是 binutils 工
具集为 WIN32 开发者提供的一个有用的补充。鉴于在链接期间的内存需求、存储需求、和链接速度
方面的大幅改进，我们预计许多开发者会尽可能的使用这个功能。

**符号别名**

有时导出一个额外的名称是很有用的。一个符号 foo 被导出为 foo，但还可以额外地导出为 _foo，
这会影响到可选生成的导入库文件。考虑下面的 DEF 文件： ::

    LIBRARY "xyz.dll" BASE=0x61000000

    EXPORTS
    foo
    _foo = foo

另一种创建一个额外的名称的方法是，在源代码中使用一个弱别名属性，参考下面的例子。更多信息
可以参考 gcc 手册中的属性以及弱符号的内容。 ::

    void foo() { /* do something */; }
    void _foo() __attribute__ ((weak, alias("foo")));

还有一种情况是，不添加额外的别名，而是将原名称改名之后导出。例如 cygwin 内核经常这样做。
符号 _foo 可以作为 foo 导出，这同样会影响到创建的导入库。例如： ::

    LIBRARY "xyz.dll" BASE=0x61000000

    EXPORTS
    _foo = foo

注意，使用 DEF 文件会禁用默认的自动导出功能，除非制定了命令行选项 --export-all-symbols。
然而，如果尝试重命名符号，那么应该在 DEF 文件中列出所有期望的导出符号，包含那些没有被重
命名的符号，并且不要使用 --export-all-symbols 选项。如果只在 DEF 文件中列出重命名的符
号，并使用了 --export-all-symbols 来处理其他符号，那么重命名符号将会和原符号一起同时导
出。实际上是添加了一个额外的名称，而不是重命名，这可能不是想要的。

**弱外部引用**

Windows 目标格式 PE 指定了一种弱符号的形式称为弱外部引用。当链接一个弱符号时没有找到这
个符号的定义，这个弱符号将变成另一个符号的别名。弱外部引用有三种变体：

1. 在其他目标文件和库文件中搜索符号的定义，历史上称为懒外部引用
2. 仅搜索其他目标文件，不搜索库文件。这种形式目前尚未实现
3. 不进行搜索，符号是一个别名。这种形式目前尚未实现

作为 GNU 的扩展，不指定一个替换符号的弱符号是支持的。如果链接时符号未定义，则符号使用默
认值。

**对齐的通用符号**

作为对 PE 目标格式的 GNU 扩展，可以指定通用符号的期望对齐字节数。这些信息是通过 GNU 特
定命令从汇编器或编译器传递到链接器的，这些命令包含在目标文件的 .drectve 分区中，由链接
器识别，并在处理通用符号内存布局时使用。使用此 GNU 扩展的目标文件可以被原生工具处理，但
这些工具将无法识别 .drectve 中的对齐指令，并可能产生关于未知链接器指令（directives）的
警告。
