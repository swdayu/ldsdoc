其他内容
=========

* `链接插件`_
* `特殊分区`_
* `MRI 脚本`_
* `BFD 库`_
* `ARM 平台`_
* `WIN32 系统`_

链接插件
--------

链接器可以使用动态加载的插件来修改链接器行为，例如一些编译器支持的链接时优化是通过链接插
件实现的。目前，默认情况下只附带了一个插件，但以后可能会添加更多插件。通过使用命令行选项
``-plugin name`` 启用插件。

**静态库依赖插件**

最初静态库被包含在一个仅由一些列重定位目标文件组成的归档文件中，后来它们发展成可以包含一
个可选的符号表，以帮助在库中找到所需的目标。这样动态链接库开始占据主导地位。

动态库的一个有用特性是，不仅仅可以将多个目标收集到一个单一文件中，而且还包含了它们的依赖
列表，这样只需在链接时指定单个动态库的名称，其所有依赖项也会被隐式引用。但静态库缺乏这一
特性，因此如果将一个链接调用从使用动态库切换到使用静态库，除非重写链接命令以显式地列出静
态库的依赖关系，否则链接命令通常会失败。

GNU ar 现在支持一个 --record-libdeps 选项，用于将依赖列表嵌入到静态库中，并且可以使用
libdep 插件在链接时读取此依赖信息。依赖信息存储为一个单独的字符串，携带着它们通常会出现
在链接器命令行中的 -l 和 -L 参数。因此，这些信息可以用任何文本工具编写，并存储到任何归档
文件中，即使不是使用 GNU ar 来创建归档文件。这些信息存在在一个名为 __.LIBDEP 的归档成
员中。

例如，假设一个库 libssl.a 依赖另一个可能位于 /usr/local/lib 的库 libcrypto.a，那么库
libssl.a 的 __.LIBDEP 成员文件将包含： ::

    -L/usr/local/lib -lcrypto

注意，以这种方式添加的任何库搜索目录仅用于搜索统一插件添加的库。它们不用于搜索链接器命令
行、链接器脚本或其他插件中指定的库。然后，如果存在多个带有 __.LIBDEP 成员的归档文件，这
将带来一个问题，因为它们都由 libdep 插件处理，因此它们会共享库搜索路径，这可能导致从一个
不预期的位置加载到一个库。

**LTO 插件**

尽管没有附带再 binutils 中，但来自 GCC 项目的链接时优化（LTO, Link Time Optimization）
插件是一个设计用来与链接器一起工作的插件。该插件拦截链接器加载的对象文件，并将它们发送给
LTO 编译器。当编译器完成后，生成的目标文件会传回给链接器进行常规处理。

特殊分区
--------

当链接 ELF 格式目标文件时，链接器会以一种特殊的非标准的方式处理一些分区。这些分区包括：

.gnu.warning
    具有此名称的任何分区的内容都假定为 ASCII 格式的警告信息。如果输入文件中出现这些分区，
    内容将显式给用户，但分区不会被复制到输出映像中。如果启用了 --fatal-warnings 选项，
    那么如果遇到警告，会结束链接器的执行。注意 .gnu.warning 分区不受链接器垃圾收集以及
    孤立分区处理的影响。
.gnu.warning.SYM
    名称以 .gnu.warning. 为前缀并以符号名称结束的任何分区，将被类似地处理为 .gnu.warning
    分区，但只有在命名符号被引用时才处理。例如，如果符号 foo 被一个或多个输入文件引用，
    名为 .gnu.warning.foo 的分区内容才被当作警告信息使用。这包括从静态库中提取的目标文
    件、完成链接解析所需的共享目标文件等等。由于这些警告信息是在链接器执行垃圾收集（如果
    启用）之前生成，因此相对于一个符号的警告信息，可能后来被移除了导致不会出现在最终的输
    出中。
.note.gnu.property
    当链接器合并该名称的分区时，会根据编码在说明分区中的各种规则进行合并。因此，输出分区
    .note.gnu.property 的内容可能不会简单地与输入分区的合并内容对应。如果使用了命令行
    选项 -Map 则链接器会生成一个映射文件，其中包含了输入分区到输出分区的详细映射信息。

MRI 脚本
---------

GNU 链接器可以帮助用户从 MRI 链接器过渡到 GNU 链接器，因为 GNU 链接器可以使用 MRI 兼容
的链接脚本，作为更通用的链接脚本语言的替代。MRI 兼容的脚本使用的命令集比GNU 链接器通用
脚本简单得多，这些命令将在下面描述。

通常，MRI 脚本在 a.out 目标文件格式上没有太大用处，因为它只有三个分区，而 MRI 脚本缺少
利用这些分区的特性。可以使用 -c 命令行选项指定一个包含 MRI 兼容脚本的文件。MRI 兼容脚本
中的每个命令都占据自己的一行，每个命令行都以标识命令关键字开始（尽管也允许使用空行作为标
点）。如果 MRI 兼容脚本的一行以无法识别的关键字开始，链接器会报警告错误，但会继续处理脚
本。以星号（*）开头的行是注释。可以使用全部大写字母或全部小写字母来书写这些命令，例如命
令 chip 与 CHIP 相同，以下是大写形式的命令列表：

ABSOLUTE secname ABSOLUTE secname, secname, ... secname
    通常情况下，链接器会在输出文件中包含输入文件中的所有分区。然而在 MRI 兼容脚本中，可
    以使用 ABSOLUTE 命令来限制出现在输出文件中的分区。如果脚本中使用了 ABSOLUTE 命令，
    则只有其中明确指定的分区才会出现在输出文件中。但仍然可以使用其他输入分区（不管是是在
    命令行设定的还是使用 LOAD 命令选择的）来解析输出文件中的地址。
ALIAS out-secname, in-secname
    使用这个命令将输入分区放置到对应的输出分区中，其中 in-secname 可能是一个整数。
ALIGN secname = expression
    将分区对齐到表达式对应的值，这个值必须是2的幂。
BASE expression
    使用表达式的值作为输出文件中的最低地址（除了绝对地址保持不变）
CHIP expression CHIP expression, expression
    该命令不做任何事，仅为兼容
END
    该命令不做任何事，仅为兼容
FORMAT output-format
    类似于通用链接语言中的 OUTPUT_FORMAT 命令用来指定输出目标文件格式。但如果输出格式
    是 S，则仅限于 S-records。
LIST anything...
    将链接映射输出到标准输出文件，就行链接器命令行选项 -M 产生的那样。LIST 关键字后面可
    以同一行跟随任意内容。
LOAD filename LOAD filename, filename, ... filename
    包含一个或多个目标文件到链接器中，跟直接在命令行指定输入文件类似。
NAME output-name
    指定链接器输出文件的名称，等价于命令行选项 -o 或者通用脚本语言中的 OUTPUT 命令。
ORDER secname, secname, ... secname ORDER secname secname secname
    通常，链接器按照输入文件中分区的出现顺序放置到输出文件中。在 MRI 兼容脚本中，可以使
    用 ORDER 命令来覆盖这种排序，使用 ORDER 列出的分区将首先出现在输出文件中，按照指定
    的顺序排列。
PUBLIC name=expression PUBLIC name,expression PUBLIC name expression
    给链接器输入文件中的外部符号指定一个表达式表示的值。
SECT secname, expression SECT secname=expression SECT secname expression
    可以使用 SECT 命令指定分区的起始地址，如果有针对同一个分区的 SECT 命令，只有第一个
    会生效。

BFD 库
-------

链接器使用 BFD（Binary File Descriptor）库来访问目标文件和归档文件。这些库允许链接器
使用相同的过程来操作目标文件，不管目标文件的格式是什么。只需要创建一个新的 BFD 后端并将
器添加到库中，就可以简单地支持不同的目标文件格式。然而，为了节省运行内存，链接器和相关工
具通常被配置为只支持可用目标文件格式的一个子集。可以使用 objdump -i 查看当前平台的配置
支持的所有格式。

与大多数实现一样，BFD 是在几个相互冲突的要求之间的折衷。影响 BFD 设计的主要因素是效率，
任何用于格式转换的时间都是本可以在不涉及 BFD 的情况下可节省的。这部分被抽象带来的好处所
抵消，因为 BFD 简化了应用程序和后端程序，更多的关注是对算法进行优化来获得更好的速度。

BFD 解决方案的另一个注意点是，在进行不同目标格式的信息转换时，或将标准的内部表示输出到
特定的目标格式时，可能存在信息丢失。

**a.out 格式**

BFD 支持多种不同风格的 a.out 格式，尽管主要的区别只是磁盘上结构的大小和重定位信息的组织
方式。该格式的支持被分为一个基本支持文件 aoutx.h 和从基础派生功能的其他文件。一个派生文
件是 aoutf1.h（用于 a.out 风格 1），它为 sun3、sun4、以及 386 a.out 文件增加了对基本
a.out 函数的支持，以创建特定目标的跳转向量。

这些信息进一步被细分为针对每种机器的更特定的文件，包括 sunos.c（针对 sun3 和 sun4），
以及 demo64.c（用于演示64位 a.out 格式）。基础文件 aoutx.h 定义了读写记录到磁盘的通用
机制以及 BFD 所需的各种其他方法。它被 aout32.c 和 aout64.c 包含以形成相对应的名字，例
如 aout_32_swap_exec_header_in、aout_64_swap_exec_header_in。

**coff 格式**

BFD 支持多种不同风格的 COFF 格式，格式之间的主要区别是磁盘上结构中的字段的大小和对齐、
以及额外的字段定义。COFF 格式的所有变体，使用通用文件和多个特定文件来实现。例如，i386
COFF 格式实现在 coff-i386.c 文件中。而文件 coff/i386.h 定义了 i386 的 COFF 格式的外
部结构，文件 coff/internal.h 定义了内部使用的结构。coff-i386 还定义了 i386 COFF 格式
使用的重定位。

**elf 格式**

目前，sparc 和 i386 的 ELF 后端格式得到了最好的支持。

**mmo 格式**

目标文件格式 mmo 是与 Donald E. Knuth 教授的教育性64位处理器 MMIX 一起专用的。可在网
站 http://mmix.cs.hm.edu/src/index.html 获取 mmix 模拟器理解此格式。该软件还包含一个
集成的汇编器和链接器，称为 mmixal。与其他格式例如 ELF 相比，mmo 格式在功能上没有任何优
势。它是一个简单的不可重定位的目标格式，不支持存档，也不支持除了符号值信息和行号外的调试
信息。有关 MMIX 的更多信息，可访问 http://mmix.cs.hm.edu/。在 BFD 实现中，使用 ELF
格式作为中间目标文件。

ARM 平台
---------

在 ARM 架构平台上，链接器会生成占位代码以便在 ARM 和 Thumb 代码之间的函数调用。这些占
位仅在打开了 -mthumb-interwork 选项进行编译和汇编的代码中有效。如果需要与旧的 ARM 目标
文件或库进行链接，而这些文件或库没有使用 --mthumb-interwork 选项来编译，那么应该向链接
器提供 --support-old-code 选项。这回产生更大的占位函数，让不能 interwork 的 ARM 代码
正常工作。但链接器不支持为不能 interwork 的 Thumb 代码生成函数调用的占位代码。

命令行选项 --thumb-entry 与 --entry 选项类似，提供程序的起始地址。但是它还设置了地址的
最低位，以便可以使用 BX 指令跳转到它的位置，然后程序就会立即进入 Thumb 模式开始执行。选
项 --use-nul-prefixed-import-tables 指定，必须为导入库生成有零元素前缀的导入表 idata4
和 idata5。这时生成导入表的旧方式，默认情况下该选项是关闭的。选项 --be8 指定链接器生成
BE8 格式的可执行文件。此选项仅在链接大端目标时有效，即那些使用了 -EB 选项进行汇编的目标。
这样生成的映像将包含大端数据和小端代码。

R_ARM_TARGET1 重定位通常用于 .init_array 分区中的条目。根据目标，它被解析为 R_ARM_REL32
或者 R_ARM_ABS32。使用 --target1-rel 和 --target1-abs 选项可以覆盖默认设置。命令行选
项 --target2-type 会覆盖 R_ARM_TARGET2 重定位的默认定义，合法的 type 值如下： ::

    rel         R_ARM_REL32 (arm*-*-elf, arm*-*-eabi)
    abs         R_ARM_ABS32
    got-rel     R_ARM_GOT_PREL (arm*-*-linux, arm*-*-*bsd)

R_ARM_V4BX 重定位（由 ARM AAELF 规范定义）使得 ARMv4 架构编译的目标可以安全的 interwork，
当与 ARMv4t 架构的目标进行链接时。同时也允许从相同的 ARMv4 目标构建除纯净的 ARMv4 二进
制文件。在有一种情况下，必须向链接器传递 --fix-v4bx 选项，这使得 v4t BX rM 指令改写成
MOV PC,rM，因为 v4 处理器没有 BX 指令。在前一种情况下，不应使用该选项，R_ARM_V4BX 重
定位会被忽略。由 R_ARM_V4BX 重定位标识的 BX rM 指令通过一个分支替换为以下代码： ::

    TST rM, #1
    MOVEQ PC, rM
    BX Rn

这允许生成的库和程序可以工作在 ARMv4 核心上，并且仍然是 interwork 安全的。但注意上面的
代码会破坏条件标记，因此在极少数情况下可能会导致程序行为不正确。选项 --use-blx 使链接器
能够在各种情况下使用 ARM/Thumb BLX 指令（在 ARMv5t 及以上版本可用）。它会根据 Thumb
代码中的 PLT 使用 BLX 进行函数调用，而不是使用 BX 指令在每个 PLT 条目之前都进行一次模
式切换。这可以提高这些调用的执行速度。

选项 --vfp11-denorm-fix 针对某些 VFP11 协处理器硬件故障启用链接时规避方法，这有时允许
具有非正规操作数的命令（必须由支持的代码处理）将这些操作数在支持的代码读取预期值之前替换
成后续的指令。在标量模式下（scalar mode）如果在使用一个寄存器的 VFP11 指令和另一个写入
同一个寄存器的指令之间允许存在至少一个中间指令，或者在矢量模式下（vector mode）至少允许
两个中间指令，那么这种故障可以避免。这种故障仅影响完全兼容的浮点模式，如果使用 runfast
模式，则不需要这种规避方法。查看 ARM 规范文档获取更大详细信息。

如果你知道你正在使用有缺陷的 VFP11 硬件，可以通过指定链接器选项 --vfp-denorm-fix=scalar
（如果仅使用 VFP11 标量模式）、或者 --vfp-denorm-fix=vector（该模式也适用于标量代码）
来启用此规避方法。它的默认值为 --vfp-denorm-fix=none。如果启用了规避方法，会扫描指令以
查找可能有问题的序列，并为可能除非故障的每个序列创建一块上面介绍的替换代码。这个替换代码
有序列的第一个指令和一个跳回到后续指令的分支组成。然后，原始指令被替换为跳转到替换指令的
分支。调用替换代码到代码返回所需的额外周期需要足够用来解决标量和矢量模式下的故障。

选项 --fix-arm1176 启用针对某些 arm1176 处理器故障的链接时规避方法。如果针对 ARMv6（不
包括 ARMv6T2）或更早版本，该规避方法默认情况下不会被启用。还可以通过指定 --no-fix-arm1176
禁用该规避方法。更多的信息参考在 ARM 文档网站（http://infocenter.arm.com/）上的程序员
建议文档（ARM1176JZ-S and ARM1176JZF-S Programmer Advice Notice）。

选项 --fix-stm3214xx-629360 启用真多某些 STM32 Cortex-M4 的产品（STM32L4xx）的总线
矩阵/内存控制器故障的链接时规避方法。当通过受影响的总线访问片外存储器时，如果总线读取超
过 9 个字长或更多，总线可能会生成损坏的数据异常终止。这些只是核心发起的访问（不是 DMA），
并且可能会影响任何访问，例如整数加载的 LDM、POP、和浮点加载的 VLDM、VPOP。存储操作不受
影响。可以通过将内存访问分割成必要的块了避免错误，以保持总线读取不超过8个字长。默认情况
下，不会启用此规避方法，这等同于使用 --fix-stm3214xx-629360=none。如果你知道你正在使
用有缺陷的 STM32L4xx 硬件，可以通过指定 --fix-stm3214xx-629360=default 或等价的选项
--fix-stm3214xx-629360 来启用规避方法。如果启用了规避方法，将扫描指令以查找可能有问题
的序列，并未可能触发错误的每个序列创建一块替换代码。当指令加载 PC 时，规避方法并不总是保
留 LDMDB 指令的内存访问顺序。当它们位于 IT 块中间时，规避方法无法处理有问题的指令，因为
那里不允许分支跳转。在这种情况下，当替换原始代码无法编码时，链接器就会报错，并且不会发生
替换。如果 .text 分区太大，规避方法无法使用 PC 相对分区指令替换有问题的指令。这种情况下，
链接器也会报错，并且不会发生替换。

选项 --no-enum-size-warning 防止链接器在链接指定了不兼容的 EABI 枚举大小属性的目标文件
时发出警告。例如将一个使用32为枚举值的目标文件，与另一个使用尽可能最小枚举值的目标文件进
行链接时，不会产生警告。选项 --no-wchar-size-warning 防止链接器在连接指定了不兼容的 EABI
wchar_t 大小属性的目标文件时发出警告。例如将使用了32位 wchar_t 值的目标文件与另一个使用
了16位 wchar_t 值得目标文件进行链接，不会产生警告。

尽管二进制文件得其余部分不是 PIC，选项 --pic-veneer 会让链接器为 ARM/Thumb 互操作的占
位代码使用 PIC 序列。这样可以避免在 uClinux 平台使用 --emit-relocs 生成可重定位二进制
文件时的问题。

链接器在尝试对很远的符号执行函数调用时，会自动生成并插入一小段代码序列到链接的 ARM ELF
可执行文件中。这些占位的指令序列的安置由命令行选项 --stub-group-size=N 控制。安置很重
要，因为错误的设置可能会导致重复的占位代码，增加代码大小。链接器会按顺序将占位代码放到一
组以减少代码流的打断，但这需要一个指导数据用来决定这些分组的大小以及放置的位置。其中参数
N 控制放置位置，如果时负数则所有替换代码放置在第一个需要它们的分支指令之后。如果时正数，
则可以放置在它们的分支指令之前或者之后。如果 N 的值为 1（不管是-1还是+1），链接器将使用
其内置启发式方法精确选择放置一组占位代码的位置。当 N 大于 1 或者小于 -1，表示一组占位代
码最多服务输入分区中的 N 个字节。如果没有指定 --stub-group-size=N，相当于 N 的默认值，
其值为正 1。远调用插入占位代码仅在 ARM-EABI 目标平台上完全支持，因为这依赖于其他目标平
台不存在的目标文件属性。

选项 --fix-cortex-a8 启用了针对某些 Cortex-A8 处理器故障的链接时规避方法。如果针对的是
ARM v7-A 架构配置文件，默认情况下会启用该规避方法。可以通过 --fix-cortex-a8 启用，或者
使用 --no-fix-cortex-a8 禁用。这个故障只影响 Thumb-2 代码，详细情况参考 ARM 规范文档。

选项 --fix-cortex-a53-835769 启用了针对 Cortex-A53 处理器某些早期版本中出现的 835769
故障的链接时规避方法。默认情况下，此规避方法是禁用的。可以使用 --fix-cortex-a53-835769
启用，或者使用 --no-fix-cortex-a53-835769 禁用。详细情况参考 ARM 规范文档。

选项 --no-merge-exidx-entries 禁用在 debuginfo 中合并相邻的 exidx 条目。--long-plt
选项启用使用16字节的 PLT 条目，这些条目支持高达 4Bb 大小的代码。默认情况下，使用12字节
的 PLT 条目，仅支持 512Mb 大小的代码。--no-apply-dynamic-relocs 使 AArch64 链接器在
链接时不应用动态重定位的值。

所有 SG 占位代码都放置在特殊的输出分区 .gnu.sgstubs 中。必须设置该分区的起始地址，要么
使用命令行选项 --section-start，要么可以在链接器脚本中设置。

选项 --cmse-implib 要求由 --out-implib 和 --in-implib 选项指定的导入库是安全网关导入
库，适用于根据 ARMv8-M 安全扩展将非安全可执行文件和安全代码进行链接。--in-implib=file
选项指定了一个输入导入库，并且其中的符号必须在正在生成的可执行文件中保持相同的地址。如果
没有指定的 --out-implib 选项，但可执行文件中引入了应该在其导入库中列出的新符号，链接器
会产生警告。否则，如果制定了 --out-implib，则会将符号添加到输出导入库中。如果输入导入库
中的一些符号在可执行文件中不存在，也会产生警告。这个选项进队安全网关导入库有效，即当指定
了 --cmse-implib 选项时。

WIN32 系统
-----------

这里描述 cygwin/mingw 等 WIN32 系统上的 GNU 链接器相关内容。

import libraries

resource only dlls

exporting dll symbols
    using auto-export functionality
    using a def file
    using decorations

automatic data imports

direct linking to a dll

symbol aliasing
    adding additional names
    renaming symbols

weak externals

aligned common symbols
